{"ast":null,"code":"import { useRef as $Qsto2$useRef, useState as $Qsto2$useState, useMemo as $Qsto2$useMemo, useEffect as $Qsto2$useEffect } from \"react\";\nimport { useControlledState as $Qsto2$useControlledState } from \"@react-stately/utils\";\nimport { compareNodeOrder as $Qsto2$compareNodeOrder, getFirstItem as $Qsto2$getFirstItem, getChildNodes as $Qsto2$getChildNodes } from \"@react-stately/collections\";\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/*\n* Copyright 2020 Adobe. All rights reserved.\n* This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License. You may obtain a copy\n* of the License at http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software distributed under\n* the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n* OF ANY KIND, either express or implied. See the License for the specific language\n* governing permissions and limitations under the License.\n*/\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nclass $e40ea825a81a3709$export$52baac22726c72bf extends Set {\n  constructor(keys, anchorKey, currentKey) {\n    super(keys);\n\n    if (keys instanceof $e40ea825a81a3709$export$52baac22726c72bf) {\n      this.anchorKey = anchorKey || keys.anchorKey;\n      this.currentKey = currentKey || keys.currentKey;\n    } else {\n      this.anchorKey = anchorKey;\n      this.currentKey = currentKey;\n    }\n  }\n\n}\n\nfunction $7af3f5b51489e0b5$var$equalSets(setA, setB) {\n  if (setA.size !== setB.size) return false;\n\n  for (let item of setA) {\n    if (!setB.has(item)) return false;\n  }\n\n  return true;\n}\n\nfunction $7af3f5b51489e0b5$export$253fe78d46329472(props) {\n  let {\n    selectionMode = \"none\",\n    disallowEmptySelection: disallowEmptySelection,\n    allowDuplicateSelectionEvents: allowDuplicateSelectionEvents,\n    selectionBehavior: selectionBehaviorProp = \"toggle\",\n    disabledBehavior = \"all\"\n  } = props; // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n  // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n\n  let isFocusedRef = (0, $Qsto2$useRef)(false);\n  let [, setFocused] = (0, $Qsto2$useState)(false);\n  let focusedKeyRef = (0, $Qsto2$useRef)(null);\n  let childFocusStrategyRef = (0, $Qsto2$useRef)(null);\n  let [, setFocusedKey] = (0, $Qsto2$useState)(null);\n  let selectedKeysProp = (0, $Qsto2$useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [props.selectedKeys]);\n  let defaultSelectedKeys = (0, $Qsto2$useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new (0, $e40ea825a81a3709$export$52baac22726c72bf)()), [props.defaultSelectedKeys]);\n  let [selectedKeys, setSelectedKeys] = (0, $Qsto2$useControlledState)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);\n  let disabledKeysProp = (0, $Qsto2$useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let [selectionBehavior, setSelectionBehavior] = (0, $Qsto2$useState)(selectionBehaviorProp); // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n  // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n\n  if (selectionBehaviorProp === \"replace\" && selectionBehavior === \"toggle\" && typeof selectedKeys === \"object\" && selectedKeys.size === 0) setSelectionBehavior(\"replace\"); // If the selectionBehavior prop changes, update the state as well.\n\n  let lastSelectionBehavior = (0, $Qsto2$useRef)(selectionBehaviorProp);\n  (0, $Qsto2$useEffect)(() => {\n    if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n      setSelectionBehavior(selectionBehaviorProp);\n      lastSelectionBehavior.current = selectionBehaviorProp;\n    }\n  }, [selectionBehaviorProp]);\n  return {\n    selectionMode: selectionMode,\n    disallowEmptySelection: disallowEmptySelection,\n    selectionBehavior: selectionBehavior,\n    setSelectionBehavior: setSelectionBehavior,\n\n    get isFocused() {\n      return isFocusedRef.current;\n    },\n\n    setFocused(f) {\n      isFocusedRef.current = f;\n      setFocused(f);\n    },\n\n    get focusedKey() {\n      return focusedKeyRef.current;\n    },\n\n    get childFocusStrategy() {\n      return childFocusStrategyRef.current;\n    },\n\n    setFocusedKey(k) {\n      let childFocusStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"first\";\n      focusedKeyRef.current = k;\n      childFocusStrategyRef.current = childFocusStrategy;\n      setFocusedKey(k);\n    },\n\n    selectedKeys: selectedKeys,\n\n    setSelectedKeys(keys) {\n      if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys)) setSelectedKeys(keys);\n    },\n\n    disabledKeys: disabledKeysProp,\n    disabledBehavior: disabledBehavior\n  };\n}\n\nfunction $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {\n  if (!selection) return defaultValue;\n  return selection === \"all\" ? \"all\" : new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selection);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n\nclass $d496c0a20b6e58ec$export$6c8a5aaad13c9852 {\n  /**\n  * The type of selection that is allowed in the collection.\n  */\n  get selectionMode() {\n    return this.state.selectionMode;\n  }\n  /**\n  * Whether the collection allows empty selection.\n  */\n\n\n  get disallowEmptySelection() {\n    return this.state.disallowEmptySelection;\n  }\n  /**\n  * The selection behavior for the collection.\n  */\n\n\n  get selectionBehavior() {\n    return this.state.selectionBehavior;\n  }\n  /**\n  * Sets the selection behavior for the collection.\n  */\n\n\n  setSelectionBehavior(selectionBehavior) {\n    this.state.setSelectionBehavior(selectionBehavior);\n  }\n  /**\n  * Whether the collection is currently focused.\n  */\n\n\n  get isFocused() {\n    return this.state.isFocused;\n  }\n  /**\n  * Sets whether the collection is focused.\n  */\n\n\n  setFocused(isFocused) {\n    this.state.setFocused(isFocused);\n  }\n  /**\n  * The current focused key in the collection.\n  */\n\n\n  get focusedKey() {\n    return this.state.focusedKey;\n  }\n  /** Whether the first or last child of the focused key should receive focus. */\n\n\n  get childFocusStrategy() {\n    return this.state.childFocusStrategy;\n  }\n  /**\n  * Sets the focused key.\n  */\n\n\n  setFocusedKey(key, childFocusStrategy) {\n    if (key == null || this.collection.getItem(key)) this.state.setFocusedKey(key, childFocusStrategy);\n  }\n  /**\n  * The currently selected keys in the collection.\n  */\n\n\n  get selectedKeys() {\n    return this.state.selectedKeys === \"all\" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;\n  }\n  /**\n  * The raw selection value for the collection.\n  * Either 'all' for select all, or a set of keys.\n  */\n\n\n  get rawSelection() {\n    return this.state.selectedKeys;\n  }\n  /**\n  * Returns whether a key is selected.\n  */\n\n\n  isSelected(key) {\n    if (this.state.selectionMode === \"none\") return false;\n    key = this.getKey(key);\n    return this.state.selectedKeys === \"all\" ? this.canSelectItem(key) : this.state.selectedKeys.has(key);\n  }\n  /**\n  * Whether the selection is empty.\n  */\n\n\n  get isEmpty() {\n    return this.state.selectedKeys !== \"all\" && this.state.selectedKeys.size === 0;\n  }\n  /**\n  * Whether all items in the collection are selected.\n  */\n\n\n  get isSelectAll() {\n    if (this.isEmpty) return false;\n    if (this.state.selectedKeys === \"all\") return true;\n    if (this._isSelectAll != null) return this._isSelectAll;\n    let allKeys = this.getSelectAllKeys();\n    let selectedKeys = this.state.selectedKeys;\n    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));\n    return this._isSelectAll;\n  }\n\n  get firstSelectedKey() {\n    let first = null;\n\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!first || item && (0, $Qsto2$compareNodeOrder)(this.collection, item, first) < 0) first = item;\n    }\n\n    return first === null || first === void 0 ? void 0 : first.key;\n  }\n\n  get lastSelectedKey() {\n    let last = null;\n\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!last || item && (0, $Qsto2$compareNodeOrder)(this.collection, item, last) > 0) last = item;\n    }\n\n    return last === null || last === void 0 ? void 0 : last.key;\n  }\n\n  get disabledKeys() {\n    return this.state.disabledKeys;\n  }\n\n  get disabledBehavior() {\n    return this.state.disabledBehavior;\n  }\n  /**\n  * Extends the selection to the given key.\n  */\n\n\n  extendSelection(toKey) {\n    if (this.selectionMode === \"none\") return;\n\n    if (this.selectionMode === \"single\") {\n      this.replaceSelection(toKey);\n      return;\n    }\n\n    toKey = this.getKey(toKey);\n    let selection; // Only select the one key if coming from a select all.\n\n    if (this.state.selectedKeys === \"all\") selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)([toKey], toKey, toKey);else {\n      let selectedKeys = this.state.selectedKeys;\n      let anchorKey = selectedKeys.anchorKey || toKey;\n      selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selectedKeys, anchorKey, toKey);\n\n      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) selection.delete(key);\n\n      for (let key1 of this.getKeyRange(toKey, anchorKey)) if (this.canSelectItem(key1)) selection.add(key1);\n    }\n    this.state.setSelectedKeys(selection);\n  }\n\n  getKeyRange(from, to) {\n    let fromItem = this.collection.getItem(from);\n    let toItem = this.collection.getItem(to);\n\n    if (fromItem && toItem) {\n      if ((0, $Qsto2$compareNodeOrder)(this.collection, fromItem, toItem) <= 0) return this.getKeyRangeInternal(from, to);\n      return this.getKeyRangeInternal(to, from);\n    }\n\n    return [];\n  }\n\n  getKeyRangeInternal(from, to) {\n    let keys = [];\n    let key = from;\n\n    while (key) {\n      let item = this.collection.getItem(key);\n      if (item && item.type === \"item\" || item.type === \"cell\" && this.allowsCellSelection) keys.push(key);\n      if (key === to) return keys;\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return [];\n  }\n\n  getKey(key) {\n    let item = this.collection.getItem(key);\n    if (!item) // ¯\\_(ツ)_/¯\n      return key; // If cell selection is allowed, just return the key.\n\n    if (item.type === \"cell\" && this.allowsCellSelection) return key; // Find a parent item to select\n\n    while (item.type !== \"item\" && item.parentKey != null) item = this.collection.getItem(item.parentKey);\n\n    if (!item || item.type !== \"item\") return null;\n    return item.key;\n  }\n  /**\n  * Toggles whether the given key is selected.\n  */\n\n\n  toggleSelection(key) {\n    if (this.selectionMode === \"none\") return;\n\n    if (this.selectionMode === \"single\" && !this.isSelected(key)) {\n      this.replaceSelection(key);\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) return;\n    let keys = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(this.state.selectedKeys === \"all\" ? this.getSelectAllKeys() : this.state.selectedKeys);\n    if (keys.has(key)) keys.delete(key);else if (this.canSelectItem(key)) {\n      keys.add(key);\n      keys.anchorKey = key;\n      keys.currentKey = key;\n    }\n    if (this.disallowEmptySelection && keys.size === 0) return;\n    this.state.setSelectedKeys(keys);\n  }\n  /**\n  * Replaces the selection with only the given key.\n  */\n\n\n  replaceSelection(key) {\n    if (this.selectionMode === \"none\") return;\n    key = this.getKey(key);\n    if (key == null) return;\n    let selection = this.canSelectItem(key) ? new (0, $e40ea825a81a3709$export$52baac22726c72bf)([key], key, key) : new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n    this.state.setSelectedKeys(selection);\n  }\n  /**\n  * Replaces the selection with the given keys.\n  */\n\n\n  setSelectedKeys(keys) {\n    if (this.selectionMode === \"none\") return;\n    let selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n\n    for (let key of keys) {\n      key = this.getKey(key);\n\n      if (key != null) {\n        selection.add(key);\n        if (this.selectionMode === \"single\") break;\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  getSelectAllKeys() {\n    let keys = [];\n\n    let addKeys = key => {\n      while (key) {\n        if (this.canSelectItem(key)) {\n          let item = this.collection.getItem(key);\n          if (item.type === \"item\") keys.push(key); // Add child keys. If cell selection is allowed, then include item children too.\n\n          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== \"item\")) addKeys((0, $Qsto2$getFirstItem)((0, $Qsto2$getChildNodes)(item, this.collection)).key);\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n    };\n\n    addKeys(this.collection.getFirstKey());\n    return keys;\n  }\n  /**\n  * Selects all items in the collection.\n  */\n\n\n  selectAll() {\n    if (this.selectionMode === \"multiple\") this.state.setSelectedKeys(\"all\");\n  }\n  /**\n  * Removes all keys from the selection.\n  */\n\n\n  clearSelection() {\n    if (!this.disallowEmptySelection && (this.state.selectedKeys === \"all\" || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new (0, $e40ea825a81a3709$export$52baac22726c72bf)());\n  }\n  /**\n  * Toggles between select all and an empty selection.\n  */\n\n\n  toggleSelectAll() {\n    if (this.isSelectAll) this.clearSelection();else this.selectAll();\n  }\n\n  select(key, e) {\n    if (this.selectionMode === \"none\") return;\n\n    if (this.selectionMode === \"single\") {\n      if (this.isSelected(key) && !this.disallowEmptySelection) this.toggleSelection(key);else this.replaceSelection(key);\n    } else if (this.selectionBehavior === \"toggle\" || e && (e.pointerType === \"touch\" || e.pointerType === \"virtual\")) // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n      this.toggleSelection(key);else this.replaceSelection(key);\n  }\n  /**\n  * Returns whether the current selection is equal to the given selection.\n  */\n\n\n  isSelectionEqual(selection) {\n    if (selection === this.state.selectedKeys) return true; // Check if the set of keys match.\n\n    let selectedKeys = this.selectedKeys;\n    if (selection.size !== selectedKeys.size) return false;\n\n    for (let key of selection) {\n      if (!selectedKeys.has(key)) return false;\n    }\n\n    for (let key1 of selectedKeys) {\n      if (!selection.has(key1)) return false;\n    }\n\n    return true;\n  }\n\n  canSelectItem(key) {\n    if (this.state.selectionMode === \"none\" || this.state.disabledKeys.has(key)) return false;\n    let item = this.collection.getItem(key);\n    if (!item || item.type === \"cell\" && !this.allowsCellSelection) return false;\n    return true;\n  }\n\n  isDisabled(key) {\n    return this.state.disabledKeys.has(key) && this.state.disabledBehavior === \"all\";\n  }\n\n  constructor(collection, state, options) {\n    this.collection = collection;\n    this.state = state;\n\n    var _options_allowsCellSelection;\n\n    this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;\n    this._isSelectAll = null;\n  }\n\n}\n\nexport { $7af3f5b51489e0b5$export$253fe78d46329472 as useMultipleSelectionState, $d496c0a20b6e58ec$export$6c8a5aaad13c9852 as SelectionManager };","map":{"version":3,"mappings":"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","names":["$e40ea825a81a3709$export$52baac22726c72bf","Set","constructor","keys","anchorKey","currentKey","$7af3f5b51489e0b5$var$equalSets","setA","setB","size","item","has","$7af3f5b51489e0b5$export$253fe78d46329472","props","selectionMode","disallowEmptySelection","allowDuplicateSelectionEvents","selectionBehavior","selectionBehaviorProp","disabledBehavior","isFocusedRef","setFocused","focusedKeyRef","childFocusStrategyRef","setFocusedKey","selectedKeysProp","$7af3f5b51489e0b5$var$convertSelection","selectedKeys","defaultSelectedKeys","setSelectedKeys","onSelectionChange","disabledKeysProp","disabledKeys","setSelectionBehavior","lastSelectionBehavior","current","isFocused","f","focusedKey","childFocusStrategy","k","selection","defaultValue","$d496c0a20b6e58ec$export$6c8a5aaad13c9852","state","key","collection","getItem","getSelectAllKeys","isSelected","getKey","canSelectItem","isEmpty","_isSelectAll","allKeys","every","first","last","extendSelection","toKey","replaceSelection","getKeyRange","delete","key1","add","from","to","fromItem","toItem","getKeyRangeInternal","type","allowsCellSelection","push","getKeyAfter","parentKey","toggleSelection","addKeys","hasChildNodes","getFirstKey","selectAll","clearSelection","toggleSelectAll","isSelectAll","select","e","pointerType","isSelectionEqual","isDisabled","options","_options_allowsCellSelection"],"sources":["/Users/vux/dev/react-project1/node_modules/@react-stately/selection/dist/packages/@react-stately/selection/src/index.ts","/Users/vux/dev/react-project1/node_modules/@react-stately/selection/dist/packages/@react-stately/selection/src/useMultipleSelectionState.ts","/Users/vux/dev/react-project1/node_modules/@react-stately/selection/dist/packages/@react-stately/selection/src/Selection.ts","/Users/vux/dev/react-project1/node_modules/@react-stately/selection/dist/packages/@react-stately/selection/src/SelectionManager.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {MultipleSelectionStateProps} from './useMultipleSelectionState';\nexport type {FocusState, SingleSelectionState, MultipleSelectionState, MultipleSelectionManager} from './types';\nexport {useMultipleSelectionState} from './useMultipleSelectionState';\nexport {SelectionManager} from './SelectionManager';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DisabledBehavior, MultipleSelection, SelectionBehavior, SelectionMode} from '@react-types/shared';\nimport {Key, useEffect, useMemo, useRef, useState} from 'react';\nimport {MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\nimport {useControlledState} from '@react-stately/utils';\n\nfunction equalSets(setA, setB) {\n  if (setA.size !== setB.size) {\n    return false;\n  }\n\n  for (let item of setA) {\n    if (!setB.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport interface MultipleSelectionStateProps extends MultipleSelection {\n  /** How multiple selection should behave in the collection. */\n  selectionBehavior?: SelectionBehavior,\n  /** Whether onSelectionChange should fire even if the new set of keys is the same as the last. */\n  allowDuplicateSelectionEvents?: boolean,\n  /** Whether `disabledKeys` applies to all interactions, or only selection. */\n  disabledBehavior?: DisabledBehavior\n}\n\n/**\n * Manages state for multiple selection and focus in a collection.\n */\nexport function useMultipleSelectionState(props: MultipleSelectionStateProps): MultipleSelectionState {\n  let {\n    selectionMode = 'none' as SelectionMode,\n    disallowEmptySelection,\n    allowDuplicateSelectionEvents,\n    selectionBehavior: selectionBehaviorProp = 'toggle',\n    disabledBehavior = 'all'\n  } = props;\n\n  // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n  // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n  let isFocusedRef = useRef(false);\n  let [, setFocused] = useState(false);\n  let focusedKeyRef = useRef(null);\n  let childFocusStrategyRef = useRef(null);\n  let [, setFocusedKey] = useState(null);\n  let selectedKeysProp = useMemo(() => convertSelection(props.selectedKeys), [props.selectedKeys]);\n  let defaultSelectedKeys = useMemo(() => convertSelection(props.defaultSelectedKeys, new Selection()), [props.defaultSelectedKeys]);\n  let [selectedKeys, setSelectedKeys] = useControlledState(\n    selectedKeysProp,\n    defaultSelectedKeys,\n    props.onSelectionChange\n  );\n  let disabledKeysProp = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n  let [selectionBehavior, setSelectionBehavior] = useState(selectionBehaviorProp);\n\n  // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n  // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n  if (selectionBehaviorProp === 'replace' && selectionBehavior === 'toggle' && typeof selectedKeys === 'object' && selectedKeys.size === 0) {\n    setSelectionBehavior('replace');\n  }\n\n  // If the selectionBehavior prop changes, update the state as well.\n  let lastSelectionBehavior = useRef(selectionBehaviorProp);\n  useEffect(() => {\n    if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n      setSelectionBehavior(selectionBehaviorProp);\n      lastSelectionBehavior.current = selectionBehaviorProp;\n    }\n  }, [selectionBehaviorProp]);\n\n  return {\n    selectionMode,\n    disallowEmptySelection,\n    selectionBehavior,\n    setSelectionBehavior,\n    get isFocused() {\n      return isFocusedRef.current;\n    },\n    setFocused(f) {\n      isFocusedRef.current = f;\n      setFocused(f);\n    },\n    get focusedKey() {\n      return focusedKeyRef.current;\n    },\n    get childFocusStrategy() {\n      return childFocusStrategyRef.current;\n    },\n    setFocusedKey(k, childFocusStrategy = 'first') {\n      focusedKeyRef.current = k;\n      childFocusStrategyRef.current = childFocusStrategy;\n      setFocusedKey(k);\n    },\n    selectedKeys,\n    setSelectedKeys(keys) {\n      if (allowDuplicateSelectionEvents || !equalSets(keys, selectedKeys)) {\n        setSelectedKeys(keys);\n      }\n    },\n    disabledKeys: disabledKeysProp,\n    disabledBehavior\n  };\n}\n\nfunction convertSelection(selection: 'all' | Iterable<Key>, defaultValue?: Selection): 'all' | Selection {\n  if (!selection) {\n    return defaultValue;\n  }\n\n  return selection === 'all'\n    ? 'all'\n    : new Selection(selection);\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\n\n/**\n * A Selection is a special Set containing Keys, which also has an anchor\n * and current selected key for use when range selecting.\n */\nexport class Selection extends Set<Key> {\n  anchorKey: Key;\n  currentKey: Key;\n\n  constructor(keys?: Iterable<Key> | Selection, anchorKey?: Key, currentKey?: Key) {\n    super(keys);\n    if (keys instanceof Selection) {\n      this.anchorKey = anchorKey || keys.anchorKey;\n      this.currentKey = currentKey || keys.currentKey;\n    } else {\n      this.anchorKey = anchorKey;\n      this.currentKey = currentKey;\n    }\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  Collection,\n  DisabledBehavior,\n  FocusStrategy,\n  Selection as ISelection,\n  LongPressEvent,\n  Node,\n  PressEvent,\n  SelectionBehavior,\n  SelectionMode\n} from '@react-types/shared';\nimport {compareNodeOrder, getChildNodes, getFirstItem} from '@react-stately/collections';\nimport {Key} from 'react';\nimport {MultipleSelectionManager, MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\n\ninterface SelectionManagerOptions {\n  allowsCellSelection?: boolean\n}\n\n/**\n * An interface for reading and updating multiple selection state.\n */\nexport class SelectionManager implements MultipleSelectionManager {\n  private collection: Collection<Node<unknown>>;\n  private state: MultipleSelectionState;\n  private allowsCellSelection: boolean;\n  private _isSelectAll: boolean;\n\n  constructor(collection: Collection<Node<unknown>>, state: MultipleSelectionState, options?: SelectionManagerOptions) {\n    this.collection = collection;\n    this.state = state;\n    this.allowsCellSelection = options?.allowsCellSelection ?? false;\n    this._isSelectAll = null;\n  }\n\n  /**\n   * The type of selection that is allowed in the collection.\n   */\n  get selectionMode(): SelectionMode {\n    return this.state.selectionMode;\n  }\n\n  /**\n   * Whether the collection allows empty selection.\n   */\n  get disallowEmptySelection(): boolean {\n    return this.state.disallowEmptySelection;\n  }\n\n  /**\n   * The selection behavior for the collection.\n   */\n  get selectionBehavior(): SelectionBehavior {\n    return this.state.selectionBehavior;\n  }\n\n  /**\n   * Sets the selection behavior for the collection.\n   */\n  setSelectionBehavior(selectionBehavior: SelectionBehavior) {\n    this.state.setSelectionBehavior(selectionBehavior);\n  }\n\n  /**\n   * Whether the collection is currently focused.\n   */\n  get isFocused(): boolean {\n    return this.state.isFocused;\n  }\n\n  /**\n   * Sets whether the collection is focused.\n   */\n  setFocused(isFocused: boolean) {\n    this.state.setFocused(isFocused);\n  }\n\n  /**\n   * The current focused key in the collection.\n   */\n  get focusedKey(): Key {\n    return this.state.focusedKey;\n  }\n\n  /** Whether the first or last child of the focused key should receive focus. */\n  get childFocusStrategy(): FocusStrategy {\n    return this.state.childFocusStrategy;\n  }\n\n  /**\n   * Sets the focused key.\n   */\n  setFocusedKey(key: Key | null, childFocusStrategy?: FocusStrategy) {\n    if (key == null || this.collection.getItem(key)) {\n      this.state.setFocusedKey(key, childFocusStrategy);\n    }\n  }\n\n  /**\n   * The currently selected keys in the collection.\n   */\n  get selectedKeys(): Set<Key> {\n    return this.state.selectedKeys === 'all'\n      ? new Set(this.getSelectAllKeys())\n      : this.state.selectedKeys;\n  }\n\n  /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */\n  get rawSelection(): ISelection {\n    return this.state.selectedKeys;\n  }\n\n  /**\n   * Returns whether a key is selected.\n   */\n  isSelected(key: Key) {\n    if (this.state.selectionMode === 'none') {\n      return false;\n    }\n\n    key = this.getKey(key);\n    return this.state.selectedKeys === 'all'\n      ? this.canSelectItem(key)\n      : this.state.selectedKeys.has(key);\n  }\n\n  /**\n   * Whether the selection is empty.\n   */\n  get isEmpty(): boolean {\n    return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n  }\n\n  /**\n   * Whether all items in the collection are selected.\n   */\n  get isSelectAll(): boolean {\n    if (this.isEmpty) {\n      return false;\n    }\n\n    if (this.state.selectedKeys === 'all') {\n      return true;\n    }\n\n    if (this._isSelectAll != null) {\n      return this._isSelectAll;\n    }\n\n    let allKeys = this.getSelectAllKeys();\n    let selectedKeys = this.state.selectedKeys;\n    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));\n    return this._isSelectAll;\n  }\n\n  get firstSelectedKey(): Key | null {\n    let first: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!first || (item && compareNodeOrder(this.collection, item, first) < 0)) {\n        first = item;\n      }\n    }\n\n    return first?.key;\n  }\n\n  get lastSelectedKey(): Key | null {\n    let last: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!last || (item && compareNodeOrder(this.collection, item, last) > 0)) {\n        last = item;\n      }\n    }\n\n    return last?.key;\n  }\n\n  get disabledKeys(): Set<Key> {\n    return this.state.disabledKeys;\n  }\n\n  get disabledBehavior(): DisabledBehavior {\n    return this.state.disabledBehavior;\n  }\n\n  /**\n   * Extends the selection to the given key.\n   */\n  extendSelection(toKey: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      this.replaceSelection(toKey);\n      return;\n    }\n\n    toKey = this.getKey(toKey);\n\n    let selection: Selection;\n\n    // Only select the one key if coming from a select all.\n    if (this.state.selectedKeys === 'all') {\n      selection = new Selection([toKey], toKey, toKey);\n    } else {\n      let selectedKeys = this.state.selectedKeys as Selection;\n      let anchorKey = selectedKeys.anchorKey || toKey;\n      selection = new Selection(selectedKeys, anchorKey, toKey);\n      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) {\n        selection.delete(key);\n      }\n\n      for (let key of this.getKeyRange(toKey, anchorKey)) {\n        if (this.canSelectItem(key)) {\n          selection.add(key);\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getKeyRange(from: Key, to: Key) {\n    let fromItem = this.collection.getItem(from);\n    let toItem = this.collection.getItem(to);\n    if (fromItem && toItem) {\n      if (compareNodeOrder(this.collection, fromItem, toItem) <= 0) {\n        return this.getKeyRangeInternal(from, to);\n      }\n\n      return this.getKeyRangeInternal(to, from);\n    }\n\n    return [];\n  }\n\n  private getKeyRangeInternal(from: Key, to: Key) {\n    let keys: Key[] = [];\n    let key = from;\n    while (key) {\n      let item = this.collection.getItem(key);\n      if (item && item.type === 'item' || (item.type === 'cell' && this.allowsCellSelection)) {\n        keys.push(key);\n      }\n\n      if (key === to) {\n        return keys;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return [];\n  }\n\n  private getKey(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      // ¯\\_(ツ)_/¯\n      return key;\n    }\n\n    // If cell selection is allowed, just return the key.\n    if (item.type === 'cell' && this.allowsCellSelection) {\n      return key;\n    }\n\n    // Find a parent item to select\n    while (item.type !== 'item' && item.parentKey != null) {\n      item = this.collection.getItem(item.parentKey);\n    }\n\n    if (!item || item.type !== 'item') {\n      return null;\n    }\n\n    return item.key;\n  }\n\n  /**\n   * Toggles whether the given key is selected.\n   */\n  toggleSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single' && !this.isSelected(key)) {\n      this.replaceSelection(key);\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let keys = new Selection(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n    if (keys.has(key)) {\n      keys.delete(key);\n      // TODO: move anchor to last selected key...\n      // Does `current` need to move here too?\n    } else if (this.canSelectItem(key)) {\n      keys.add(key);\n      keys.anchorKey = key;\n      keys.currentKey = key;\n    }\n\n    if (this.disallowEmptySelection && keys.size === 0) {\n      return;\n    }\n\n    this.state.setSelectedKeys(keys);\n  }\n\n  /**\n   * Replaces the selection with only the given key.\n   */\n  replaceSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let selection = this.canSelectItem(key)\n      ? new Selection([key], key, key)\n      : new Selection();\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  /**\n   * Replaces the selection with the given keys.\n   */\n  setSelectedKeys(keys: Iterable<Key>) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    let selection = new Selection();\n    for (let key of keys) {\n      key = this.getKey(key);\n      if (key != null) {\n        selection.add(key);\n        if (this.selectionMode === 'single') {\n          break;\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getSelectAllKeys() {\n    let keys: Key[] = [];\n    let addKeys = (key: Key) => {\n      while (key) {\n        if (this.canSelectItem(key)) {\n          let item = this.collection.getItem(key);\n          if (item.type === 'item') {\n            keys.push(key);\n          }\n\n          // Add child keys. If cell selection is allowed, then include item children too.\n          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== 'item')) {\n            addKeys(getFirstItem(getChildNodes(item, this.collection)).key);\n          }\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n    };\n\n    addKeys(this.collection.getFirstKey());\n    return keys;\n  }\n\n  /**\n   * Selects all items in the collection.\n   */\n  selectAll() {\n    if (this.selectionMode === 'multiple') {\n      this.state.setSelectedKeys('all');\n    }\n  }\n\n  /**\n   * Removes all keys from the selection.\n   */\n  clearSelection() {\n    if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) {\n      this.state.setSelectedKeys(new Selection());\n    }\n  }\n\n  /**\n   * Toggles between select all and an empty selection.\n   */\n  toggleSelectAll() {\n    if (this.isSelectAll) {\n      this.clearSelection();\n    } else {\n      this.selectAll();\n    }\n  }\n\n  select(key: Key, e?: PressEvent | LongPressEvent | PointerEvent) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      if (this.isSelected(key) && !this.disallowEmptySelection) {\n        this.toggleSelection(key);\n      } else {\n        this.replaceSelection(key);\n      }\n    } else if (this.selectionBehavior === 'toggle' || (e && (e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n      // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n      this.toggleSelection(key);\n    } else {\n      this.replaceSelection(key);\n    }\n  }\n\n  /**\n   * Returns whether the current selection is equal to the given selection.\n   */\n  isSelectionEqual(selection: Set<Key>) {\n    if (selection === this.state.selectedKeys) {\n      return true;\n    }\n\n    // Check if the set of keys match.\n    let selectedKeys = this.selectedKeys;\n    if (selection.size !== selectedKeys.size) {\n      return false;\n    }\n\n    for (let key of selection) {\n      if (!selectedKeys.has(key)) {\n        return false;\n      }\n    }\n\n    for (let key of selectedKeys) {\n      if (!selection.has(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  canSelectItem(key: Key) {\n    if (this.state.selectionMode === 'none' || this.state.disabledKeys.has(key)) {\n      return false;\n    }\n\n    let item = this.collection.getItem(key);\n    if (!item || (item.type === 'cell' && !this.allowsCellSelection)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  isDisabled(key: Key) {\n    return this.state.disabledKeys.has(key) && this.state.disabledBehavior === 'all';\n  }\n}\n"]},"metadata":{},"sourceType":"module"}