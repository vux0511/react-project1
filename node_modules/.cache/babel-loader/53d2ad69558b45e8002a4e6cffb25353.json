{"ast":null,"code":"import { useReducer as $d70Aq$useReducer, useEffect as $d70Aq$useEffect, useState as $d70Aq$useState, useMemo as $d70Aq$useMemo } from \"react\";\n\nfunction $0d86e9c8f07f9a7b$export$762f73dccccd255d(options) {\n  let {\n    initialItems = [],\n    initialSelectedKeys: initialSelectedKeys,\n    getKey = item => item.id || item.key,\n    filter: filter,\n    initialFilterText = ''\n  } = options; // Store both items and filteredItems in state so we can go back to the unfiltered list\n\n  let [state, setState] = $d70Aq$useState({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n    filterText: initialFilterText\n  });\n  let filteredItems = $d70Aq$useMemo(() => filter ? state.items.filter(item => filter(item, state.filterText)) : state.items, [state.items, state.filterText, filter]);\n  return { ...state,\n    items: filteredItems,\n    ...$0d86e9c8f07f9a7b$export$79c0c687a5963b0a({\n      getKey: getKey\n    }, setState),\n\n    getItem(key) {\n      return state.items.find(item => getKey(item) === key);\n    }\n\n  };\n}\n\nfunction $0d86e9c8f07f9a7b$export$79c0c687a5963b0a(opts, dispatch) {\n  let {\n    cursor: cursor,\n    getKey: getKey\n  } = opts;\n  return {\n    setSelectedKeys(selectedKeys) {\n      dispatch(state => ({ ...state,\n        selectedKeys: selectedKeys\n      }));\n    },\n\n    setFilterText(filterText) {\n      dispatch(state => ({ ...state,\n        filterText: filterText\n      }));\n    },\n\n    insert(index) {\n      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        values[_key - 1] = arguments[_key];\n      }\n\n      dispatch(state => $0d86e9c8f07f9a7b$var$insert(state, index, ...values));\n    },\n\n    insertBefore(key) {\n      for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        values[_key2 - 1] = arguments[_key2];\n      }\n\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) return;\n        return $0d86e9c8f07f9a7b$var$insert(state, index, ...values);\n      });\n    },\n\n    insertAfter(key) {\n      for (var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        values[_key3 - 1] = arguments[_key3];\n      }\n\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) return;\n        return $0d86e9c8f07f9a7b$var$insert(state, index + 1, ...values);\n      });\n    },\n\n    prepend() {\n      for (var _len4 = arguments.length, values = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        values[_key4] = arguments[_key4];\n      }\n\n      dispatch(state => $0d86e9c8f07f9a7b$var$insert(state, 0, ...values));\n    },\n\n    append() {\n      for (var _len5 = arguments.length, values = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        values[_key5] = arguments[_key5];\n      }\n\n      dispatch(state => $0d86e9c8f07f9a7b$var$insert(state, state.items.length, ...values));\n    },\n\n    remove() {\n      for (var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        keys[_key6] = arguments[_key6];\n      }\n\n      dispatch(state => {\n        let keySet = new Set(keys);\n        let items = state.items.filter(item => !keySet.has(getKey(item)));\n        let selection = 'all';\n\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n\n          for (let key of keys) selection.delete(key);\n        }\n\n        if (cursor == null && items.length === 0) selection = new Set();\n        return { ...state,\n          items: items,\n          selectedKeys: selection\n        };\n      });\n    },\n\n    removeSelectedItems() {\n      dispatch(state => {\n        if (state.selectedKeys === 'all') return { ...state,\n          items: [],\n          selectedKeys: new Set()\n        };\n        let selectedKeys = state.selectedKeys;\n        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));\n        return { ...state,\n          items: items,\n          selectedKeys: new Set()\n        };\n      });\n    },\n\n    move(key, toIndex) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) return state;\n        let copy = state.items.slice();\n        let [item1] = copy.splice(index, 1);\n        copy.splice(toIndex, 0, item1);\n        return { ...state,\n          items: copy\n        };\n      });\n    },\n\n    moveBefore(key1, keys) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key1);\n        if (toIndex === -1) return state; // Find indices of keys to move. Sort them so that the order in the list is retained.\n\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex);\n      });\n    },\n\n    moveAfter(key2, keys) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key2);\n        if (toIndex === -1) return state;\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex + 1);\n      });\n    },\n\n    update(key, newValue) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) return state;\n        return { ...state,\n          items: [...state.items.slice(0, index), newValue, ...state.items.slice(index + 1)]\n        };\n      });\n    }\n\n  };\n}\n\nfunction $0d86e9c8f07f9a7b$var$insert(state, index) {\n  for (var _len7 = arguments.length, values = new Array(_len7 > 2 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++) {\n    values[_key7 - 2] = arguments[_key7];\n  }\n\n  return { ...state,\n    items: [...state.items.slice(0, index), ...values, ...state.items.slice(index)]\n  };\n}\n\nfunction $0d86e9c8f07f9a7b$var$move(state, indices, toIndex) {\n  // Shift the target down by the number of items being moved from before the target\n  for (let index of indices) if (index < toIndex) toIndex--;\n\n  let moves = indices.map(from => ({\n    from: from,\n    to: toIndex++\n  })); // Shift later from indices down if they have a larger index\n\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i].from;\n\n    for (let j = i; j < moves.length; j++) {\n      let b = moves[j].from;\n      if (b > a) moves[j].from--;\n    }\n  } // Interleave the moves so they can be applied one by one rather than all at once\n\n\n  for (let i1 = 0; i1 < moves.length; i1++) {\n    let a = moves[i1];\n\n    for (let j = moves.length - 1; j > i1; j--) {\n      let b = moves[j];\n      if (b.from < a.to) a.to++;else b.from++;\n    }\n  }\n\n  let copy = state.items.slice();\n\n  for (let move of moves) {\n    let [item] = copy.splice(move.from, 1);\n    copy.splice(move.to, 0, item);\n  }\n\n  return { ...state,\n    items: copy\n  };\n}\n\nfunction $f86e6c1ec7da6ebb$var$reducer(data, action) {\n  let selectedKeys;\n\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          var _filterText, _sortDescriptor;\n\n          return { ...data,\n            filterText: (_filterText = action.filterText) !== null && _filterText !== void 0 ? _filterText : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: (_sortDescriptor = action.sortDescriptor) !== null && _sortDescriptor !== void 0 ? _sortDescriptor : data.sortDescriptor,\n            abortController: action.abortController\n          };\n\n        case 'update':\n          return { ...data,\n            ...action.updater(data)\n          };\n\n        case 'success':\n        case 'error':\n          return data;\n\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) return data;\n\n          var _selectedKeys;\n\n          selectedKeys = (_selectedKeys = action.selectedKeys) !== null && _selectedKeys !== void 0 ? _selectedKeys : data.selectedKeys;\n\n          var _filterText1, _sortDescriptor1;\n\n          return { ...data,\n            filterText: (_filterText1 = action.filterText) !== null && _filterText1 !== void 0 ? _filterText1 : data.filterText,\n            state: 'idle',\n            items: [...action.items],\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: (_sortDescriptor1 = action.sortDescriptor) !== null && _sortDescriptor1 !== void 0 ? _sortDescriptor1 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n\n        case 'error':\n          if (action.abortController !== data.abortController) return data;\n          return { ...data,\n            state: 'error',\n            error: action.error,\n            abortController: null\n          };\n\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n\n          var _filterText2;\n\n          return { ...data,\n            filterText: (_filterText2 = action.filterText) !== null && _filterText2 !== void 0 ? _filterText2 : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return { ...data,\n            ...action.updater(data)\n          };\n\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          var _selectedKeys1;\n\n          selectedKeys = data.selectedKeys === 'all' || action.selectedKeys === 'all' ? 'all' : new Set([...data.selectedKeys, ...((_selectedKeys1 = action.selectedKeys) !== null && _selectedKeys1 !== void 0 ? _selectedKeys1 : [])]);\n\n          var _sortDescriptor2; // Append the new items\n\n\n          return { ...data,\n            state: 'idle',\n            items: [...data.items, ...action.items],\n            selectedKeys: selectedKeys,\n            sortDescriptor: (_sortDescriptor2 = action.sortDescriptor) !== null && _sortDescriptor2 !== void 0 ? _sortDescriptor2 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n\n        case 'error':\n          if (action.abortController !== data.abortController) return data;\n          return { ...data,\n            state: 'error',\n            error: action.error\n          };\n\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n\n          var _filterText3;\n\n          return { ...data,\n            filterText: (_filterText3 = action.filterText) !== null && _filterText3 !== void 0 ? _filterText3 : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController.abort();\n          return data;\n\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return { ...data,\n            ...action.updater(data)\n          };\n\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\n\nfunction $f86e6c1ec7da6ebb$export$bc3384a35de93d66(options) {\n  const {\n    load: load,\n    sort: sort,\n    initialSelectedKeys: initialSelectedKeys,\n    initialSortDescriptor: initialSortDescriptor,\n    getKey = item => item.id || item.key,\n    initialFilterText = ''\n  } = options;\n  let [data, dispatch] = $d70Aq$useReducer($f86e6c1ec7da6ebb$var$reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  });\n\n  const dispatchFetch = async (action, fn) => {\n    let abortController = new AbortController();\n\n    try {\n      dispatch({ ...action,\n        abortController: abortController\n      });\n\n      var _filterText;\n\n      let previousFilterText = (_filterText = action.filterText) !== null && _filterText !== void 0 ? _filterText : data.filterText;\n\n      var _sortDescriptor;\n\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: (_sortDescriptor = action.sortDescriptor) !== null && _sortDescriptor !== void 0 ? _sortDescriptor : data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : null,\n        filterText: previousFilterText\n      });\n\n      var _filterText4;\n\n      let filterText = (_filterText4 = response.filterText) !== null && _filterText4 !== void 0 ? _filterText4 : previousFilterText;\n      dispatch({\n        type: 'success',\n        ...response,\n        abortController: abortController\n      }); // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n      // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n\n      if (filterText && filterText !== previousFilterText && !abortController.signal.aborted) dispatchFetch({\n        type: 'filtering',\n        filterText: filterText\n      }, load);\n    } catch (e) {\n      dispatch({\n        type: 'error',\n        error: e,\n        abortController: abortController\n      });\n    }\n  };\n\n  $d70Aq$useEffect(() => {\n    dispatchFetch({\n      type: 'loading'\n    }, load); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return {\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n\n    getItem(key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n\n    reload() {\n      dispatchFetch({\n        type: 'loading'\n      }, load);\n    },\n\n    loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) return;\n      dispatchFetch({\n        type: 'loadingMore'\n      }, load);\n    },\n\n    sort(sortDescriptor) {\n      dispatchFetch({\n        type: 'sorting',\n        sortDescriptor: sortDescriptor\n      }, sort || load);\n    },\n\n    ...$0d86e9c8f07f9a7b$export$79c0c687a5963b0a({ ...options,\n      getKey: getKey,\n      cursor: data.cursor\n    }, fn => {\n      dispatch({\n        type: 'update',\n        updater: fn\n      });\n    }),\n\n    setFilterText(filterText) {\n      dispatchFetch({\n        type: 'filtering',\n        filterText: filterText\n      }, load);\n    }\n\n  };\n}\n\nfunction $be2ea0343af54212$export$d14e1352e21f4a16(options) {\n  let {\n    initialItems: initialItems1 = [],\n    initialSelectedKeys: initialSelectedKeys,\n    getKey = item => item.id || item.key,\n    getChildren = item => item.children\n  } = options;\n  let map = $d70Aq$useMemo(() => new Map(), []); // We only want to compute this on initial render.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  let initialNodes = $d70Aq$useMemo(() => buildTree(initialItems1), []);\n  let [items1, setItems] = $d70Aq$useState(initialNodes);\n  let [selectedKeys, setSelectedKeys] = $d70Aq$useState(new Set(initialSelectedKeys || []));\n\n  function buildTree() {\n    let initialItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let parentKey = arguments.length > 1 ? arguments[1] : undefined;\n    return initialItems.map(item => {\n      let node = {\n        key: getKey(item),\n        parentKey: parentKey,\n        value: item,\n        children: null\n      };\n      node.children = buildTree(getChildren(item), node.key);\n      map.set(node.key, node);\n      return node;\n    });\n  }\n\n  function updateTree(items, key, update) {\n    let node = map.get(key);\n    if (!node) return items; // Create a new node. If null, then delete the node, otherwise replace.\n\n    let newNode = update(node);\n    if (newNode == null) deleteNode(node);else addNode(newNode); // Walk up the tree and update each parent to refer to the new chilren.\n\n    while (node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n      let children = nextParent.children;\n      if (newNode == null) children = children.filter(c => c !== node);\n      copy.children = children.map(child => {\n        if (child === node) return newNode;\n        return child;\n      });\n      map.set(copy.key, copy);\n      newNode = copy;\n      node = nextParent;\n    }\n\n    if (newNode == null) items = items.filter(c => c !== node);\n    return items.map(item => {\n      if (item === node) return newNode;\n      return item;\n    });\n  }\n\n  function addNode(node) {\n    map.set(node.key, node);\n\n    for (let child of node.children) addNode(child);\n  }\n\n  function deleteNode(node) {\n    map.delete(node.key);\n\n    for (let child of node.children) deleteNode(child);\n  }\n\n  return {\n    items: items1,\n    selectedKeys: selectedKeys,\n    setSelectedKeys: setSelectedKeys,\n\n    getItem(key) {\n      return map.get(key);\n    },\n\n    insert(parentKey, index) {\n      for (var _len8 = arguments.length, values = new Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {\n        values[_key8 - 2] = arguments[_key8];\n      }\n\n      setItems(items => {\n        let nodes = buildTree(values, parentKey); // If parentKey is null, insert into the root.\n\n        if (parentKey == null) return [...items.slice(0, index), ...nodes, ...items.slice(index)]; // Otherwise, update the parent node and its ancestors.\n\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [...parentNode.children.slice(0, index), ...nodes, ...parentNode.children.slice(index)]\n        }));\n      });\n    },\n\n    insertBefore(key) {\n      let node = map.get(key);\n      if (!node) return;\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items1;\n      let index = nodes.indexOf(node);\n\n      for (var _len9 = arguments.length, values = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n        values[_key9 - 1] = arguments[_key9];\n      }\n\n      this.insert(parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index, ...values);\n    },\n\n    insertAfter(key) {\n      let node = map.get(key);\n      if (!node) return;\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items1;\n      let index = nodes.indexOf(node);\n\n      for (var _len10 = arguments.length, values = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n        values[_key10 - 1] = arguments[_key10];\n      }\n\n      this.insert(parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index + 1, ...values);\n    },\n\n    prepend(parentKey) {\n      for (var _len11 = arguments.length, values = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n        values[_key11 - 1] = arguments[_key11];\n      }\n\n      this.insert(parentKey, 0, ...values);\n    },\n\n    append(parentKey) {\n      for (var _len12 = arguments.length, values = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n        values[_key12 - 1] = arguments[_key12];\n      }\n\n      if (parentKey == null) this.insert(null, items1.length, ...values);else {\n        let parentNode = map.get(parentKey);\n        if (!parentNode) return;\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n\n    remove() {\n      let newItems = items1;\n\n      for (var _len13 = arguments.length, keys = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        keys[_key13] = arguments[_key13];\n      }\n\n      for (let key of keys) newItems = updateTree(newItems, key, () => null);\n\n      setItems(newItems);\n      let selection = new Set(selectedKeys);\n\n      for (let key1 of selectedKeys) if (!map.has(key1)) selection.delete(key1);\n\n      setSelectedKeys(selection);\n    },\n\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n\n    move(key, toParentKey, index) {\n      setItems(items => {\n        let node = map.get(key);\n        if (!node) return items;\n        items = updateTree(items, key, () => null);\n        const movedNode = { ...node,\n          parentKey: toParentKey\n        };\n        return updateTree(items, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [...parentNode.children.slice(0, index), movedNode, ...parentNode.children.slice(index)]\n        }));\n      });\n    },\n\n    update(oldKey, newValue) {\n      setItems(items => updateTree(items, oldKey, oldNode => {\n        let node = {\n          key: oldNode.key,\n          parentKey: oldNode.parentKey,\n          value: newValue,\n          children: null\n        };\n        node.children = buildTree(getChildren(newValue), node.key);\n        return node;\n      }));\n    }\n\n  };\n}\n\nexport { $f86e6c1ec7da6ebb$export$bc3384a35de93d66 as useAsyncList, $be2ea0343af54212$export$d14e1352e21f4a16 as useTreeData, $0d86e9c8f07f9a7b$export$762f73dccccd255d as useListData };","map":{"version":3,"mappings":"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","names":["$0d86e9c8f07f9a7b$export$762f73dccccd255d","options","initialItems","initialSelectedKeys","getKey","item","id","key","filter","initialFilterText","state","setState","$d70Aq$useState","items","selectedKeys","Set","filterText","filteredItems","$d70Aq$useMemo","$0d86e9c8f07f9a7b$export$79c0c687a5963b0a","getItem","find","opts","dispatch","cursor","setSelectedKeys","setFilterText","insert","index","values","$0d86e9c8f07f9a7b$var$insert","insertBefore","findIndex","insertAfter","prepend","append","length","remove","keys","keySet","has","selection","delete","removeSelectedItems","move","toIndex","copy","slice","item1","splice","moveBefore","key1","keyArray","Array","isArray","indices","map","sort","$0d86e9c8f07f9a7b$var$move","moveAfter","key2","update","newValue","moves","from","to","i","a","j","b","i1","$f86e6c1ec7da6ebb$var$reducer","data","action","type","_filterText","_sortDescriptor","sortDescriptor","abortController","updater","Error","_selectedKeys","_filterText1","_sortDescriptor1","error","abort","_filterText2","_selectedKeys1","_sortDescriptor2","_filterText3","$f86e6c1ec7da6ebb$export$bc3384a35de93d66","load","initialSortDescriptor","$d70Aq$useReducer","dispatchFetch","fn","AbortController","previousFilterText","response","signal","_filterText4","aborted","e","$d70Aq$useEffect","isLoading","loadingState","reload","loadMore","$be2ea0343af54212$export$d14e1352e21f4a16","initialItems1","getChildren","children","Map","initialNodes","buildTree","items1","setItems","parentKey","node","value","set","updateTree","get","newNode","deleteNode","addNode","nextParent","c","child","nodes","parentNode","indexOf","newItems","toParentKey","movedNode","oldKey","oldNode"],"sources":["/Users/vux/dev/react-project1/node_modules/@react-stately/data/dist/packages/@react-stately/data/src/useListData.ts","/Users/vux/dev/react-project1/node_modules/@react-stately/data/dist/packages/@react-stately/data/src/useAsyncList.ts","/Users/vux/dev/react-project1/node_modules/@react-stately/data/dist/packages/@react-stately/data/src/useTreeData.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useMemo, useState} from 'react';\nimport {Selection} from '@react-types/shared';\n\nexport interface ListOptions<T> {\n  /** Initial items in the list. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: 'all' | Iterable<Key>,\n  /** The initial text to filter the list by. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns whether a item matches the current filter text. */\n  filter?: (item: T, filterText: string) => boolean\n}\n\nexport interface ListData<T> {\n  /** The items in the list. */\n  items: T[],\n\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Selection): void,\n\n  /** The current filter text. */\n  filterText: string,\n\n  /** Sets the filter text. */\n  setFilterText(filterText: string): void,\n\n  /**\n   * Gets an item from the list by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): T,\n\n  /**\n   * Inserts items into the list at the given index.\n   * @param index - The index to insert into.\n   * @param values - The values to insert.\n   */\n  insert(index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends items to the list.\n   * @param values - The values to insert.\n   */\n  append(...values: T[]): void,\n\n  /**\n   * Prepends items to the list.\n   * @param value - The value to insert.\n   */\n  prepend(...values: T[]): void,\n\n  /**\n   * Removes items from the list by their keys.\n   * @param keys - The keys of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the list that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the list.\n   * @param key - The key of the item to move.\n   * @param toIndex - The index to move the item to.\n   */\n  move(key: Key, toIndex: number): void,\n\n  /**\n   * Moves one or more items before a given key.\n   * @param key - The key of the item to move the items before.\n   * @param keys - The keys of the items to move.\n   */\n  moveBefore(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Moves one or more items after a given key.\n   * @param key - The key of the item to move the items after.\n   * @param keys - The keys of the items to move.\n   */\n  moveAfter(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Updates an item in the list.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\nexport interface ListState<T> {\n  items: T[],\n  selectedKeys: Selection,\n  filterText: string\n}\n\ninterface CreateListOptions<T, C> extends ListOptions<T> {\n  cursor?: C\n}\n\n/**\n * Manages state for an immutable list data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useListData<T>(options: ListOptions<T>): ListData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    filter,\n    initialFilterText = ''\n  } = options;\n\n  // Store both items and filteredItems in state so we can go back to the unfiltered list\n  let [state, setState] = useState<ListState<T>>({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n    filterText: initialFilterText\n  });\n\n  let filteredItems = useMemo(\n    () => filter ? state.items.filter(item => filter(item, state.filterText)) : state.items,\n    [state.items, state.filterText, filter]);\n\n  return {\n    ...state,\n    items: filteredItems,\n    ...createListActions({getKey}, setState),\n    getItem(key: Key) {\n      return state.items.find(item => getKey(item) === key);\n    }\n  };\n}\n\nexport function createListActions<T, C>(opts: CreateListOptions<T, C>, dispatch: (updater: (state: ListState<T>) => ListState<T>) => void): Omit<ListData<T>, 'items' | 'selectedKeys' | 'getItem' | 'filterText'> {\n  let {cursor, getKey} = opts;\n  return {\n    setSelectedKeys(selectedKeys: Selection) {\n      dispatch(state => ({\n        ...state,\n        selectedKeys\n      }));\n    },\n    setFilterText(filterText: string) {\n      dispatch(state => ({\n        ...state,\n        filterText\n      }));\n    },\n    insert(index: number, ...values: T[]) {\n      dispatch(state => insert(state, index, ...values));\n    },\n    insertBefore(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return;\n        }\n\n        return insert(state, index, ...values);\n      });\n    },\n    insertAfter(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return;\n        }\n\n        return insert(state, index + 1, ...values);\n      });\n    },\n    prepend(...values: T[]) {\n      dispatch(state => insert(state, 0, ...values));\n    },\n    append(...values: T[]) {\n      dispatch(state => insert(state, state.items.length, ...values));\n    },\n    remove(...keys: Key[]) {\n      dispatch(state => {\n        let keySet = new Set(keys);\n        let items = state.items.filter(item => !keySet.has(getKey(item)));\n\n        let selection: Selection = 'all';\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n          for (let key of keys) {\n            selection.delete(key);\n          }\n        }\n        if (cursor == null && items.length === 0) {\n          selection = new Set();\n        }\n\n        return {\n          ...state,\n          items,\n          selectedKeys: selection\n        };\n      });\n    },\n    removeSelectedItems() {\n      dispatch(state => {\n        if (state.selectedKeys === 'all') {\n          return {\n            ...state,\n            items: [],\n            selectedKeys: new Set()\n          };\n        }\n\n        let selectedKeys = state.selectedKeys;\n        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));\n        return {\n          ...state,\n          items,\n          selectedKeys: new Set()\n        };\n      });\n    },\n    move(key: Key, toIndex: number) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        let copy = state.items.slice();\n        let [item] = copy.splice(index, 1);\n        copy.splice(toIndex, 0, item);\n        return {\n          ...state,\n          items: copy\n        };\n      });\n    },\n    moveBefore(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        // Find indices of keys to move. Sort them so that the order in the list is retained.\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return move(state, indices, toIndex);\n      });\n    },\n    moveAfter(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return move(state, indices, toIndex + 1);\n      });\n    },\n    update(key: Key, newValue: T) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        return {\n          ...state,\n          items: [\n            ...state.items.slice(0, index),\n            newValue,\n            ...state.items.slice(index + 1)\n          ]\n        };\n      });\n    }\n  };\n}\n\nfunction insert<T>(state: ListState<T>, index: number, ...values: T[]): ListState<T> {\n  return {\n    ...state,\n    items: [\n      ...state.items.slice(0, index),\n      ...values,\n      ...state.items.slice(index)\n    ]\n  };\n}\n\nfunction move<T>(state: ListState<T>, indices: number[], toIndex: number): ListState<T> {\n  // Shift the target down by the number of items being moved from before the target\n  for (let index of indices) {\n    if (index < toIndex) {\n      toIndex--;\n    }\n  }\n\n  let moves = indices.map(from => ({\n    from,\n    to: toIndex++\n  }));\n\n  // Shift later from indices down if they have a larger index\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i].from;\n    for (let j = i; j < moves.length; j++) {\n      let b = moves[j].from;\n\n      if (b > a) {\n        moves[j].from--;\n      }\n    }\n  }\n\n  // Interleave the moves so they can be applied one by one rather than all at once\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i];\n    for (let j = moves.length - 1; j > i; j--) {\n      let b = moves[j];\n\n      if (b.from < a.to) {\n        a.to++;\n      } else {\n        b.from++;\n      }\n    }\n  }\n\n  let copy = state.items.slice();\n  for (let move of moves) {\n    let [item] = copy.splice(move.from, 1);\n    copy.splice(move.to, 0, item);\n  }\n\n  return {\n    ...state,\n    items: copy\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createListActions, ListData, ListState} from './useListData';\nimport {Key, Reducer, useEffect, useReducer} from 'react';\nimport {LoadingState, Selection, SortDescriptor} from '@react-types/shared';\n\nexport interface AsyncListOptions<T, C> {\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** The initial sort descriptor. */\n  initialSortDescriptor?: SortDescriptor,\n  /** The initial filter text. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that loads the data for the items in the list. */\n  load: AsyncListLoadFunction<T, C>,\n  /**\n   * An optional function that performs sorting. If not provided,\n   * then `sortDescriptor` is passed to the `load` function.\n   */\n  sort?: AsyncListLoadFunction<T, C>\n}\n\ntype AsyncListLoadFunction<T, C> = (state: AsyncListLoadOptions<T, C>) => AsyncListStateUpdate<T, C> | Promise<AsyncListStateUpdate<T, C>>;\n\ninterface AsyncListLoadOptions<T, C> {\n  /** The items currently in the list. */\n  items: T[],\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n  /** The current sort descriptor for the list. */\n  sortDescriptor: SortDescriptor,\n  /** An abort signal used to notify the load function that the request has been aborted. */\n  signal: AbortSignal,\n  /** The pagination cursor returned from the last page load. */\n  cursor?: C,\n  /** The current filter text used to perform server side filtering. */\n  filterText?: string,\n  /** The current loading state of the list. */\n  loadingState?: LoadingState\n}\n\ninterface AsyncListStateUpdate<T, C> {\n  /** The new items to append to the list. */\n  items: Iterable<T>,\n  /** The keys to add to the selection. */\n  selectedKeys?: Iterable<Key>,\n  /** The sort descriptor to set. */\n  sortDescriptor?: SortDescriptor,\n  /** The pagination cursor to be used for the next page load. */\n  cursor?: C,\n  /** The updated filter text for the list. */\n  filterText?: string\n}\n\ninterface AsyncListState<T, C> extends ListState<T> {\n  state: LoadingState,\n  items: T[],\n  // disabledKeys?: Iterable<Key>,\n  selectedKeys: Selection,\n  // selectedKey?: Key,\n  // expandedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  cursor?: C\n}\n\ntype ActionType = 'success' | 'error' | 'loading' | 'loadingMore' | 'sorting' | 'update' | 'filtering';\ninterface Action<T, C> {\n  type: ActionType,\n  items?: Iterable<T>,\n  selectedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  updater?: (state: ListState<T>) => ListState<T>,\n  cursor?: C,\n  filterText?: string\n}\n\nexport interface AsyncListData<T> extends ListData<T> {\n  /** Whether data is currently being loaded. */\n  isLoading: boolean,\n  /** If loading data failed, then this contains the error that occurred. */\n  error?: Error,\n  // disabledKeys?: Set<Key>,\n  // selectedKey?: Key,\n  // expandedKeys?: Set<Key>,\n  /** The current sort descriptor for the list. */\n  sortDescriptor?: SortDescriptor,\n\n  /** Reloads the data in the list. */\n  reload(): void,\n  /** Loads the next page of data in the list. */\n  loadMore(): void,\n  /** Triggers sorting for the list. */\n  sort(descriptor: SortDescriptor): void,\n  /** The current loading state for the list. */\n  loadingState: LoadingState\n}\n\nfunction reducer<T, C>(data: AsyncListState<T, C>, action: Action<T, C>): AsyncListState<T, C> {\n  let selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: action.abortController\n          };\n        case 'update':\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          selectedKeys = action.selectedKeys ?? data.selectedKeys;\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: 'idle',\n            items: [...action.items],\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error,\n            abortController: null\n          };\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          selectedKeys = (data.selectedKeys === 'all' || action.selectedKeys === 'all')\n            ? 'all'\n            : new Set([...data.selectedKeys, ...(action.selectedKeys ?? [])]);\n          // Append the new items\n          return {\n            ...data,\n            state: 'idle',\n            items: [...data.items, ...action.items],\n            selectedKeys,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error\n          };\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController.abort();\n\n          return data;\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\n\n/**\n * Manages state for an immutable async loaded list data structure, and provides convenience methods to\n * update the data over time. Manages loading and error states, pagination, and sorting.\n */\nexport function useAsyncList<T, C = string>(options: AsyncListOptions<T, C>): AsyncListData<T> {\n  const {\n    load,\n    sort,\n    initialSelectedKeys,\n    initialSortDescriptor,\n    getKey = (item: any) => item.id || item.key,\n    initialFilterText = ''\n  } = options;\n\n  let [data, dispatch] = useReducer<Reducer<AsyncListState<T, C>, Action<T, C>>>(reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  });\n\n  const dispatchFetch = async (action: Action<T, C>, fn: AsyncListLoadFunction<T, C>) => {\n    let abortController = new AbortController();\n    try {\n      dispatch({...action, abortController});\n      let previousFilterText = action.filterText ?? data.filterText;\n\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : null,\n        filterText: previousFilterText\n      });\n\n      let filterText = response.filterText ?? previousFilterText;\n      dispatch({type: 'success', ...response, abortController});\n\n      // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n      // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n      if (filterText && (filterText !== previousFilterText) && !abortController.signal.aborted) {\n        dispatchFetch({type: 'filtering', filterText}, load);\n      }\n    } catch (e) {\n      dispatch({type: 'error', error: e, abortController});\n    }\n  };\n\n  useEffect(() => {\n    dispatchFetch({type: 'loading'}, load);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem(key: Key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n    reload() {\n      dispatchFetch({type: 'loading'}, load);\n    },\n    loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) {\n        return;\n      }\n\n      dispatchFetch({type: 'loadingMore'}, load);\n    },\n    sort(sortDescriptor: SortDescriptor) {\n      dispatchFetch({type: 'sorting', sortDescriptor}, sort || load);\n    },\n    ...createListActions({...options, getKey, cursor: data.cursor}, fn => {\n      dispatch({type: 'update', updater: fn});\n    }),\n    setFilterText(filterText: string) {\n      dispatchFetch({type: 'filtering', filterText}, load);\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useMemo, useState} from 'react';\n\nexport interface TreeOptions<T extends object> {\n  /** Initial root items in the tree. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns the children for an item object. */\n  getChildren?: (item: T) => T[]\n}\n\ninterface TreeNode<T extends object> {\n  /** A unique key for the tree node. */\n  key: Key,\n  /** The key of the parent node. */\n  parentKey: Key,\n  /** The value object for the tree node. */\n  value: T,\n  /** Children of the tree node. */\n  children: TreeNode<T>[]\n}\n\nexport interface TreeData<T extends object> {\n  /** The root nodes in the tree. */\n  items: TreeNode<T>[],\n\n  /** The keys of the currently selected items in the tree. */\n  selectedKeys: Set<Key>,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Set<Key>): void,\n\n  /**\n   * Gets a node from the tree by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): TreeNode<T>,\n\n  /**\n   * Inserts an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param index - The index within the parent to insert into.\n   * @param value - The value to insert.\n   */\n  insert(parentKey: Key | null, index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  append(parentKey: Key | null, ...values: T[]): void,\n\n  /**\n   * Prepends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  prepend(parentKey: Key | null, ...value: T[]): void,\n\n  /**\n   * Removes an item from the tree by its key.\n   * @param key - The key of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the tree that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the tree.\n   * @param key - The key of the item to move.\n   * @param toParentKey - The key of the new parent to insert into.\n   * @param index - The index within the new parent to insert at.\n   */\n  move(key: Key, toParentKey: Key, index: number): void,\n\n  /**\n   * Updates an item in the tree.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\n/**\n * Manages state for an immutable tree data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useTreeData<T extends object>(options: TreeOptions<T>): TreeData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    getChildren = (item: any) => item.children\n  } = options;\n  let map = useMemo(() => new Map<Key, TreeNode<T>>(), []);\n\n  // We only want to compute this on initial render.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  let initialNodes = useMemo(() => buildTree(initialItems), []);\n  let [items, setItems] = useState(initialNodes);\n  let [selectedKeys, setSelectedKeys] = useState(new Set<Key>(initialSelectedKeys || []));\n\n  function buildTree(initialItems: T[] = [], parentKey?: Key | null) {\n    return initialItems.map(item => {\n      let node: TreeNode<T> = {\n        key: getKey(item),\n        parentKey: parentKey,\n        value: item,\n        children: null\n      };\n\n      node.children = buildTree(getChildren(item), node.key);\n      map.set(node.key, node);\n      return node;\n    });\n  }\n\n  function updateTree(items: TreeNode<T>[], key: Key, update: (node: TreeNode<T>) => TreeNode<T>) {\n    let node = map.get(key);\n    if (!node) {\n      return items;\n    }\n\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) {\n      deleteNode(node);\n    } else {\n      addNode(newNode);\n    }\n\n    // Walk up the tree and update each parent to refer to the new chilren.\n    while (node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy: TreeNode<T> = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n\n      let children = nextParent.children;\n      if (newNode == null) {\n        children = children.filter(c => c !== node);\n      }\n\n      copy.children = children.map(child => {\n        if (child === node) {\n          return newNode;\n        }\n\n        return child;\n      });\n\n      map.set(copy.key, copy);\n\n      newNode = copy;\n      node = nextParent;\n    }\n\n    if (newNode == null) {\n      items = items.filter(c => c !== node);\n    }\n\n    return items.map(item => {\n      if (item === node) {\n        return newNode;\n      }\n\n      return item;\n    });\n  }\n\n  function addNode(node: TreeNode<T>) {\n    map.set(node.key, node);\n    for (let child of node.children) {\n      addNode(child);\n    }\n  }\n\n  function deleteNode(node: TreeNode<T>) {\n    map.delete(node.key);\n    for (let child of node.children) {\n      deleteNode(child);\n    }\n  }\n\n  return {\n    items,\n    selectedKeys,\n    setSelectedKeys,\n    getItem(key: Key) {\n      return map.get(key);\n    },\n    insert(parentKey: Key | null, index: number, ...values: T[]) {\n      setItems(items => {\n        let nodes = buildTree(values, parentKey);\n\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) {\n          return [\n            ...items.slice(0, index),\n            ...nodes,\n            ...items.slice(index)\n          ];\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            ...nodes,\n            ...parentNode.children.slice(index)\n          ]\n        }));\n      });\n    },\n    insertBefore(key: Key, ...values: T[]): void {\n      let node = map.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index, ...values);\n    },\n    insertAfter(key: Key, ...values: T[]): void {\n      let node = map.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index + 1, ...values);\n    },\n    prepend(parentKey: Key | null, ...values: T[]) {\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey: Key | null, ...values: T[]) {\n      if (parentKey == null) {\n        this.insert(null, items.length, ...values);\n      } else {\n        let parentNode = map.get(parentKey);\n        if (!parentNode) {\n          return;\n        }\n\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n    remove(...keys: Key[]) {\n      let newItems = items;\n      for (let key of keys) {\n        newItems = updateTree(newItems, key, () => null);\n      }\n\n      setItems(newItems);\n\n      let selection = new Set(selectedKeys);\n      for (let key of selectedKeys) {\n        if (!map.has(key)) {\n          selection.delete(key);\n        }\n      }\n\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key: Key, toParentKey: Key, index: number) {\n      setItems(items => {\n        let node = map.get(key);\n        if (!node) {\n          return items;\n        }\n\n        items = updateTree(items, key, () => null);\n\n        const movedNode = {\n          ...node,\n          parentKey: toParentKey\n        };\n\n        return updateTree(items, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            movedNode,\n            ...parentNode.children.slice(index)\n          ]\n        }));\n      });\n    },\n    update(oldKey: Key, newValue: T) {\n      setItems(items => updateTree(items, oldKey, oldNode => {\n        let node: TreeNode<T> = {\n          key: oldNode.key,\n          parentKey: oldNode.parentKey,\n          value: newValue,\n          children: null\n        };\n\n        node.children = buildTree(getChildren(newValue), node.key);\n        return node;\n      }));\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}