{"ast":null,"code":"import { getChildNodes as $cAn5f$getChildNodes, getLastItem as $cAn5f$getLastItem, getFirstItem as $cAn5f$getFirstItem } from \"@react-stately/collections\";\nimport { useMemo as $cAn5f$useMemo, useRef as $cAn5f$useRef, useEffect as $cAn5f$useEffect } from \"react\";\nimport { useMultipleSelectionState as $cAn5f$useMultipleSelectionState, SelectionManager as $cAn5f$SelectionManager } from \"@react-stately/selection\";\nimport $cAn5f$swchelperssrc_define_propertymjs from \"@swc/helpers/src/_define_property.mjs\";\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $62967d126f3aa823$export$4007ac09ff9c68ed(props) {\n  let {\n    collection: collection,\n    focusMode: focusMode\n  } = props;\n  let selectionState = (0, $cAn5f$useMultipleSelectionState)(props);\n  let disabledKeys = (0, $cAn5f$useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let setFocusedKey = selectionState.setFocusedKey;\n\n  selectionState.setFocusedKey = (key, child) => {\n    // If focusMode is cell and an item is focused, focus a child cell instead.\n    if (focusMode === \"cell\" && key != null) {\n      let item = collection.getItem(key);\n\n      if ((item === null || item === void 0 ? void 0 : item.type) === \"item\") {\n        var _getLastItem, _getFirstItem;\n\n        let children = (0, $cAn5f$getChildNodes)(item, collection);\n        if (child === \"last\") key = (_getLastItem = (0, $cAn5f$getLastItem)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;else key = (_getFirstItem = (0, $cAn5f$getFirstItem)(children)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n      }\n    }\n\n    setFocusedKey(key, child);\n  };\n\n  let selectionManager = (0, $cAn5f$useMemo)(() => new (0, $cAn5f$SelectionManager)(collection, selectionState), [collection, selectionState]); // Reset focused key if that item is deleted from the collection.\n\n  const cachedCollection = (0, $cAn5f$useRef)(null);\n  (0, $cAn5f$useEffect)(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      const node = cachedCollection.current.getItem(selectionState.focusedKey);\n      const parentNode = node.parentKey != null && (node.type === \"cell\" || node.type === \"rowheader\" || node.type === \"column\") ? cachedCollection.current.getItem(node.parentKey) : node;\n      const cachedRows = cachedCollection.current.rows;\n      const rows = collection.rows;\n      const diff = cachedRows.length - rows.length;\n      let index = Math.min(diff > 1 ? Math.max(parentNode.index - diff + 1, 0) : parentNode.index, rows.length - 1);\n      let newRow;\n\n      while (index >= 0) {\n        if (!selectionManager.isDisabled(rows[index].key)) {\n          newRow = rows[index];\n          break;\n        } // Find next, not disabled row.\n\n\n        if (index < rows.length - 1) index++;else {\n          if (index > parentNode.index) index = parentNode.index;\n          index--;\n        }\n      }\n\n      if (newRow) {\n        const childNodes = newRow.hasChildNodes ? [...(0, $cAn5f$getChildNodes)(newRow, collection)] : [];\n        const keyToFocus = newRow.hasChildNodes && parentNode !== node && node.index < childNodes.length ? childNodes[node.index].key : newRow.key;\n        selectionState.setFocusedKey(keyToFocus);\n      } else selectionState.setFocusedKey(null);\n    }\n\n    cachedCollection.current = collection;\n  }, [collection, selectionManager, selectionState, selectionState.focusedKey]);\n  return {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    isKeyboardNavigationDisabled: false,\n    selectionManager: selectionManager\n  };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n\nlet $16805b1b18093c5f$var$_Symbol_iterator = Symbol.iterator;\n\nclass $16805b1b18093c5f$export$de3fdf6493c353d {\n  *[$16805b1b18093c5f$var$_Symbol_iterator]() {\n    yield* [...this.rows];\n  }\n\n  get size() {\n    return [...this.rows].length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    var _;\n\n    return (_ = [...this.rows][0]) === null || _ === void 0 ? void 0 : _.key;\n  }\n\n  getLastKey() {\n    var _rows_;\n\n    let rows = [...this.rows];\n    return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;\n  }\n\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n  getChildren(key) {\n    let node = this.keyMap.get(key);\n    return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n  }\n\n  constructor(opts) {\n    (0, $cAn5f$swchelperssrc_define_propertymjs)(this, \"keyMap\", new Map());\n    this.keyMap = new Map();\n    this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;\n    this.rows = [];\n\n    let visit = node => {\n      // If the node is the same object as the previous node for the same key,\n      // we can skip this node and its children. We always visit columns though,\n      // because we depend on order to build the columns array.\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) node = opts.visitNode(node);\n      this.keyMap.set(node.key, node);\n      let childKeys = new Set();\n      let last;\n\n      for (let child of node.childNodes) {\n        if (child.type === \"cell\" && child.parentKey == null) // if child is a cell parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        childKeys.add(child.key);\n\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else child.prevKey = null;\n\n        visit(child);\n        last = child;\n      }\n\n      if (last) last.nextKey = null; // Remove deleted nodes and their children from the key map\n\n      if (prevNode) {\n        for (let child1 of prevNode.childNodes) if (!childKeys.has(child1.key)) remove(child1);\n      }\n    };\n\n    let remove = node => {\n      this.keyMap.delete(node.key);\n\n      for (let child of node.childNodes) if (this.keyMap.get(child.key) === child) remove(child);\n    };\n\n    let last;\n    opts.items.forEach((node, i) => {\n      let rowNode = {\n        level: 0,\n        key: \"row-\" + i,\n        type: \"row\",\n        value: undefined,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: undefined,\n        textValue: undefined,\n        ...node,\n        index: i\n      };\n\n      if (last) {\n        last.nextKey = rowNode.key;\n        rowNode.prevKey = last.key;\n      } else rowNode.prevKey = null;\n\n      this.rows.push(rowNode);\n      visit(rowNode);\n      last = rowNode;\n    });\n    if (last) last.nextKey = null;\n  }\n\n}\n\nexport { $62967d126f3aa823$export$4007ac09ff9c68ed as useGridState, $16805b1b18093c5f$export$de3fdf6493c353d as GridCollection };","map":{"version":3,"mappings":"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","names":["$62967d126f3aa823$export$4007ac09ff9c68ed","props","collection","focusMode","selectionState","disabledKeys","Set","setFocusedKey","key","child","item","getItem","type","_getLastItem","_getFirstItem","children","selectionManager","cachedCollection","focusedKey","node","current","parentNode","parentKey","cachedRows","rows","diff","length","index","Math","min","max","newRow","isDisabled","childNodes","hasChildNodes","keyToFocus","isKeyboardNavigationDisabled","$16805b1b18093c5f$var$_Symbol_iterator","iterator","$16805b1b18093c5f$export$de3fdf6493c353d","getKeys","keyMap","keys","getKeyBefore","get","prevKey","getKeyAfter","nextKey","getFirstKey","_","getLastKey","_rows_","at","idx","getChildren","constructor","opts","Map","columnCount","visit","prevNode","visitNode","set","childKeys","last","add","child1","has","remove","delete","items","forEach","i","rowNode","level","value","undefined","rendered","textValue","push"],"sources":["/Users/vux/dev/react-project1/node_modules/@react-stately/grid/dist/packages/@react-stately/grid/src/index.ts","/Users/vux/dev/react-project1/node_modules/@react-stately/grid/dist/packages/@react-stately/grid/src/useGridState.ts","/Users/vux/dev/react-project1/node_modules/@react-stately/grid/dist/packages/@react-stately/grid/src/GridCollection.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useGridState} from './useGridState';\nexport {GridCollection} from './GridCollection';\n\nexport type {GridStateOptions, GridState} from './useGridState';\n","import {getChildNodes, getFirstItem, getLastItem} from '@react-stately/collections';\nimport {GridCollection, GridNode} from '@react-types/grid';\nimport {Key, useEffect, useMemo, useRef} from 'react';\nimport {MultipleSelectionStateProps, SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\n\nexport interface GridState<T, C extends GridCollection<T>> {\n  collection: C,\n  /** A set of keys for rows that are disabled. */\n  disabledKeys: Set<Key>,\n  /** A selection manager to read and update row selection state. */\n  selectionManager: SelectionManager,\n  /** Whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  isKeyboardNavigationDisabled: boolean\n}\n\nexport interface GridStateOptions<T, C extends GridCollection<T>> extends MultipleSelectionStateProps {\n  collection: C,\n  disabledKeys?: Iterable<Key>,\n  focusMode?: 'row' | 'cell'\n}\n\n/**\n * Provides state management for a grid component. Handles row selection and focusing a grid cell's focusable child if applicable.\n */\nexport function useGridState<T extends object, C extends GridCollection<T>>(props: GridStateOptions<T, C>): GridState<T, C> {\n  let {collection, focusMode} = props;\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n      props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n    , [props.disabledKeys]);\n\n  let setFocusedKey = selectionState.setFocusedKey;\n  selectionState.setFocusedKey = (key, child) => {\n    // If focusMode is cell and an item is focused, focus a child cell instead.\n    if (focusMode === 'cell' && key != null) {\n      let item = collection.getItem(key);\n      if (item?.type === 'item') {\n        let children = getChildNodes(item, collection);\n        if (child === 'last') {\n          key = getLastItem(children)?.key;\n        } else {\n          key = getFirstItem(children)?.key;\n        }\n      }\n    }\n\n    setFocusedKey(key, child);\n  };\n\n  let selectionManager = useMemo(() =>\n    new SelectionManager(collection, selectionState)\n    , [collection, selectionState]\n  );\n\n  // Reset focused key if that item is deleted from the collection.\n  const cachedCollection = useRef(null);\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      const node = cachedCollection.current.getItem(selectionState.focusedKey);\n      const parentNode =\n        node.parentKey != null && (node.type === 'cell' || node.type === 'rowheader' || node.type === 'column') ?\n        cachedCollection.current.getItem(node.parentKey) :\n        node;\n      const cachedRows = cachedCollection.current.rows;\n      const rows = collection.rows;\n      const diff = cachedRows.length - rows.length;\n      let index = Math.min(\n        (\n          diff > 1 ?\n          Math.max(parentNode.index - diff + 1, 0) :\n          parentNode.index\n        ),\n        rows.length - 1);\n      let newRow:GridNode<T>;\n      while (index >= 0) {\n        if (!selectionManager.isDisabled(rows[index].key)) {\n          newRow = rows[index];\n          break;\n        }\n        // Find next, not disabled row.\n        if (index < rows.length - 1) {\n          index++;\n        // Otherwise, find previous, not disabled row.\n        } else {\n          if (index > parentNode.index) {\n            index = parentNode.index;\n          }\n          index--;\n        }\n      }\n      if (newRow) {\n        const childNodes = newRow.hasChildNodes ? [...getChildNodes(newRow, collection)] : [];\n        const keyToFocus =\n          newRow.hasChildNodes &&\n          parentNode !== node &&\n          node.index < childNodes.length ?\n          childNodes[node.index].key :\n          newRow.key;\n        selectionState.setFocusedKey(keyToFocus);\n      } else {\n        selectionState.setFocusedKey(null);\n      }\n    }\n    cachedCollection.current = collection;\n  }, [collection, selectionManager, selectionState, selectionState.focusedKey]);\n\n  return {\n    collection,\n    disabledKeys,\n    isKeyboardNavigationDisabled: false,\n    selectionManager\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {GridNode, GridRow, GridCollection as IGridCollection} from '@react-types/grid';\nimport {Key} from 'react';\n\n\ninterface GridCollectionOptions<T> {\n  columnCount: number,\n  items: GridRow<T>[],\n  visitNode?: (cell: GridNode<T>) => GridNode<T>\n}\n\nexport class GridCollection<T> implements IGridCollection<T> {\n  keyMap: Map<Key, GridNode<T>> = new Map();\n  columnCount: number;\n  rows: GridNode<T>[];\n\n  constructor(opts?: GridCollectionOptions<T>) {\n    this.keyMap = new Map();\n    this.columnCount = opts?.columnCount;\n    this.rows = [];\n\n    let visit = (node: GridNode<T>) => {\n      // If the node is the same object as the previous node for the same key,\n      // we can skip this node and its children. We always visit columns though,\n      // because we depend on order to build the columns array.\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) {\n        node = opts.visitNode(node);\n      }\n\n      this.keyMap.set(node.key, node);\n\n      let childKeys = new Set();\n      let last: GridNode<T>;\n      for (let child of node.childNodes) {\n        if (child.type === 'cell' && child.parentKey == null) {\n          // if child is a cell parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        }\n        childKeys.add(child.key);\n\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else {\n          child.prevKey = null;\n        }\n\n        visit(child);\n        last = child;\n      }\n\n      if (last) {\n        last.nextKey = null;\n      }\n\n      // Remove deleted nodes and their children from the key map\n      if (prevNode) {\n        for (let child of prevNode.childNodes) {\n          if (!childKeys.has(child.key)) {\n            remove(child);\n          }\n        }\n      }\n    };\n\n    let remove = (node: GridNode<T>) => {\n      this.keyMap.delete(node.key);\n      for (let child of node.childNodes) {\n        if (this.keyMap.get(child.key) === child) {\n          remove(child);\n        }\n      }\n    };\n\n    let last: GridNode<T>;\n    opts.items.forEach((node, i) => {\n      let rowNode = {\n        level: 0,\n        key: 'row-' + i,\n        type: 'row',\n        value: undefined,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: undefined,\n        textValue: undefined,\n        ...node,\n        index: i\n      } as GridNode<T>;\n\n      if (last) {\n        last.nextKey = rowNode.key;\n        rowNode.prevKey = last.key;\n      } else {\n        rowNode.prevKey = null;\n      }\n\n      this.rows.push(rowNode);\n      visit(rowNode);\n\n      last = rowNode;\n    });\n\n    if (last) {\n      last.nextKey = null;\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* [...this.rows];\n  }\n\n  get size() {\n    return [...this.rows].length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return [...this.rows][0]?.key;\n  }\n\n  getLastKey() {\n    let rows = [...this.rows];\n    return rows[rows.length - 1]?.key;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n  getChildren(key: Key): Iterable<GridNode<T>> {\n    let node = this.keyMap.get(key);\n    return node?.childNodes || [];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}