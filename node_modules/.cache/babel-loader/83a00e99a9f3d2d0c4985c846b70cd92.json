{"ast":null,"code":"import { Section as $6555104ff085bef4$re_export$Section, useCollection as $1BfjW$useCollection } from \"@react-stately/collections\";\nimport $1BfjW$react, { useRef as $1BfjW$useRef, useState as $1BfjW$useState, useCallback as $1BfjW$useCallback, useMemo as $1BfjW$useMemo } from \"react\";\nimport { useGridState as $1BfjW$useGridState, GridCollection as $1BfjW$GridCollection } from \"@react-stately/grid\";\n\nfunction $30561577df230a30$export$f61abf052f87399f(widths) {\n  return Array.from(widths).map(e => e[1]).reduce((acc, cur) => acc + cur, 0);\n}\n\nfunction $30561577df230a30$export$1994a077b98ee0d5(width) {\n  return width != null && (!isNaN(width) || String(width).match(/^(\\d+)(?=%$)/) !== null);\n}\n\nfunction $30561577df230a30$var$parseFractionalUnit(width) {\n  if (!width) return 1;\n  let match = width.match(/^(\\d+)(?=fr$)/); // if width is the incorrect format, just deafult it to a 1fr\n\n  if (!match) {\n    console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, 'defaulting to \\'1fr\\'');\n    return 1;\n  }\n\n  return parseInt(match[0], 10);\n}\n\nfunction $30561577df230a30$export$7bbad27896f7ae9f(width, tableWidth) {\n  if (typeof width === 'string') {\n    let match = width.match(/^(\\d+)(?=%$)/);\n    if (!match) throw new Error('Only percentages or numbers are supported for static column widths');\n    return tableWidth * (parseInt(match[0], 10) / 100);\n  }\n\n  return width;\n}\n\nfunction $30561577df230a30$export$59185c62a7544aa0(maxWidth, tableWidth) {\n  return maxWidth != null ? $30561577df230a30$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;\n}\n\nfunction $30561577df230a30$export$f556054ce4358701(minWidth, tableWidth) {\n  return minWidth != null ? $30561577df230a30$export$7bbad27896f7ae9f(minWidth, tableWidth) : 75;\n}\n\nfunction $30561577df230a30$var$mapDynamicColumns(dynamicColumns, availableSpace, tableWidth) {\n  let fractions = dynamicColumns.reduce((sum, column) => sum + $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth), 0);\n  let columns = dynamicColumns.map((column, index) => {\n    const targetWidth = $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth) * availableSpace / fractions;\n    const delta = Math.max($30561577df230a30$export$f556054ce4358701(column.props.minWidth, tableWidth) - targetWidth, targetWidth - $30561577df230a30$export$59185c62a7544aa0(column.props.maxWidth, tableWidth));\n    return { ...column,\n      index: index,\n      delta: delta\n    };\n  });\n  return columns;\n}\n\nfunction $30561577df230a30$var$findDynamicColumnWidths(dynamicColumns, availableSpace, tableWidth) {\n  let fractions = dynamicColumns.reduce((sum, col) => sum + $30561577df230a30$var$parseFractionalUnit(col.props.defaultWidth), 0);\n  const columns = dynamicColumns.map(column => {\n    const targetWidth = $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth) * availableSpace / fractions;\n    let width = Math.max($30561577df230a30$export$f556054ce4358701(column.props.minWidth, tableWidth), Math.min(Math.floor(targetWidth), $30561577df230a30$export$59185c62a7544aa0(column.props.maxWidth, tableWidth)));\n    column.calculatedWidth = width;\n    availableSpace -= width;\n    fractions -= $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth);\n    return column;\n  });\n  return columns;\n}\n\nfunction $30561577df230a30$export$a870e6692ac5ccb2(dynamicColumns, availableSpace, tableWidth) {\n  let columns = $30561577df230a30$var$mapDynamicColumns(dynamicColumns, availableSpace, tableWidth);\n  columns.sort((a, b) => b.delta - a.delta);\n  columns = $30561577df230a30$var$findDynamicColumnWidths(columns, availableSpace, tableWidth);\n  columns.sort((a, b) => a.index - b.index);\n  return columns;\n}\n\nfunction $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {\n  const {\n    getDefaultWidth: getDefaultWidth,\n    tableWidth: defaultTableWidth = null\n  } = props;\n  const {\n    columns: columns1\n  } = state;\n  const columnsRef = $1BfjW$useRef([]);\n  const tableWidth = $1BfjW$useRef(defaultTableWidth);\n  const isResizing = $1BfjW$useRef(null);\n  const startResizeContentWidth = $1BfjW$useRef();\n  const [columnWidths, setColumnWidths] = $1BfjW$useState(new Map(columns1.map(col => [col.key, 0])));\n  const columnWidthsRef = $1BfjW$useRef(columnWidths);\n  const affectedColumnWidthsRef = $1BfjW$useRef([]);\n  const [resizedColumns, setResizedColumns] = $1BfjW$useState(new Set());\n  const resizedColumnsRef = $1BfjW$useRef(resizedColumns);\n  const [currentlyResizingColumn, setCurrentlyResizingColumn] = $1BfjW$useState(null);\n\n  function setColumnWidthsForRef(newWidths) {\n    columnWidthsRef.current = newWidths; // new map so that change detection is triggered\n\n    setColumnWidths(newWidths);\n  }\n  /*\n  returns the resolved column width in this order:\n  previously calculated width -> controlled width prop -> uncontrolled defaultWidth prop -> dev assigned width -> default dynamic width\n  */\n\n\n  let getResolvedColumnWidth = $1BfjW$useCallback(column => {\n    let columnProps = column.props;\n\n    var _width, ref, ref1;\n\n    return (resizedColumns === null || resizedColumns === void 0 ? void 0 : resizedColumns.has(column.key)) ? columnWidthsRef.current.get(column.key) : (ref1 = (ref = (_width = columnProps.width) !== null && _width !== void 0 ? _width : columnProps.defaultWidth) !== null && ref !== void 0 ? ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(column.props)) !== null && ref1 !== void 0 ? ref1 : '1fr';\n  }, [getDefaultWidth, resizedColumns]);\n  let getStaticAndDynamicColumns = $1BfjW$useCallback(columns => columns.reduce((acc, column) => {\n    let width = getResolvedColumnWidth(column);\n    return $30561577df230a30$export$1994a077b98ee0d5(width) ? { ...acc,\n      staticColumns: [...acc.staticColumns, column]\n    } : { ...acc,\n      dynamicColumns: [...acc.dynamicColumns, column]\n    };\n  }, {\n    staticColumns: [],\n    dynamicColumns: []\n  }), [getResolvedColumnWidth]);\n  let buildColumnWidths = $1BfjW$useCallback((affectedColumns, availableSpace) => {\n    const widths = new Map();\n    let remainingSpace = availableSpace;\n    const {\n      staticColumns: staticColumns,\n      dynamicColumns: dynamicColumns\n    } = getStaticAndDynamicColumns(affectedColumns);\n    staticColumns.forEach(column => {\n      let width = getResolvedColumnWidth(column);\n      let w = $30561577df230a30$export$7bbad27896f7ae9f(width, tableWidth.current);\n      widths.set(column.key, w);\n      remainingSpace -= w;\n    }); // dynamic columns\n\n    if (dynamicColumns.length > 0) {\n      const newColumnWidths = $30561577df230a30$export$a870e6692ac5ccb2(dynamicColumns, remainingSpace, tableWidth.current);\n\n      for (let column of newColumnWidths) widths.set(column.key, column.calculatedWidth);\n    }\n\n    return widths;\n  }, [getStaticAndDynamicColumns, getResolvedColumnWidth]);\n  const prevColKeys = columnsRef.current.map(col => col.key);\n  const colKeys = columns1.map(col => col.key); // if the columns change, need to rebuild widths.\n\n  if (prevColKeys.length !== colKeys.length || !colKeys.every((col, i) => col === prevColKeys[i])) {\n    columnsRef.current = columns1;\n    const widths = buildColumnWidths(columns1, tableWidth.current);\n    setColumnWidthsForRef(widths);\n  }\n\n  function setTableWidth(width) {\n    if (width && width !== tableWidth.current) {\n      tableWidth.current = width;\n\n      if (!isResizing.current) {\n        const widths = buildColumnWidths(columns1, width);\n        setColumnWidthsForRef(widths);\n      }\n    }\n  }\n\n  function onColumnResizeStart(column) {\n    setCurrentlyResizingColumn(column.key);\n    isResizing.current = true;\n    startResizeContentWidth.current = $30561577df230a30$export$f61abf052f87399f(columnWidthsRef.current);\n  }\n\n  function onColumnResize(column, width) {\n    let widthsObj = resizeColumn(column, width);\n    affectedColumnWidthsRef.current = widthsObj;\n    props.onColumnResize && props.onColumnResize(affectedColumnWidthsRef.current);\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  function onColumnResizeEnd(column) {\n    props.onColumnResizeEnd && isResizing.current && props.onColumnResizeEnd(affectedColumnWidthsRef.current);\n    setCurrentlyResizingColumn(null);\n    isResizing.current = false;\n    affectedColumnWidthsRef.current = [];\n    let widths = new Map(columnWidthsRef.current);\n    setColumnWidthsForRef(widths);\n  }\n\n  function resizeColumn(column1, newWidth) {\n    let boundedWidth = Math.max($30561577df230a30$export$f556054ce4358701(column1.props.minWidth, tableWidth.current), Math.min(Math.floor(newWidth), $30561577df230a30$export$59185c62a7544aa0(column1.props.maxWidth, tableWidth.current))); // copy the columnWidths map and set the new width for the column being resized\n\n    let widths = new Map(columnWidthsRef.current);\n    widths.set(column1.key, boundedWidth); // keep track of all columns that have been sized\n\n    resizedColumnsRef.current.add(column1.key);\n    setResizedColumns(resizedColumnsRef.current); // get the columns affected by resize and remaining space\n\n    const resizeIndex = columnsRef.current.findIndex(col => col.key === column1.key);\n    let affectedColumns = columnsRef.current.slice(resizeIndex + 1); // we only care about the columns that CAN be resized, we ignore static columns.\n\n    let {\n      dynamicColumns: dynamicColumns\n    } = getStaticAndDynamicColumns(affectedColumns); // available space for affected columns\n\n    let availableSpace = columnsRef.current.reduce((acc, column, index) => {\n      if (index <= resizeIndex || $30561577df230a30$export$1994a077b98ee0d5(getResolvedColumnWidth(column))) return acc - widths.get(column.key);\n      return acc;\n    }, tableWidth.current); // merge the unaffected column widths and the recalculated column widths\n\n    let recalculatedColumnWidths = buildColumnWidths(dynamicColumns, availableSpace);\n    widths = new Map([...widths, ...recalculatedColumnWidths]);\n    setColumnWidthsForRef(widths);\n    /*\n    when getting recalculated columns above, the column being resized is not considered \"recalculated\"\n    so we need to add it to the list of affected columns\n    */\n\n    let allAffectedColumns = [[column1.key, boundedWidth], ...recalculatedColumnWidths].map(_ref => {\n      let [key, width] = _ref;\n      return {\n        key: key,\n        width: width\n      };\n    });\n    return allAffectedColumns;\n  }\n\n  var ref2; // This function is regenerated whenever columnWidthsRef.current changes in order to get the new correct ref value.\n\n  let getColumnWidth = $1BfjW$useCallback(key => (ref2 = columnWidthsRef.current.get(key)) !== null && ref2 !== void 0 ? ref2 : 0, [columnWidthsRef.current]);\n  let getColumnMinWidth = $1BfjW$useCallback(key => {\n    const columnIndex = columns1.findIndex(col => col.key === key);\n    if (columnIndex === -1) return;\n    return $30561577df230a30$export$f556054ce4358701(columns1[columnIndex].props.minWidth, tableWidth.current);\n  }, [columns1]);\n  let getColumnMaxWidth = $1BfjW$useCallback(key => {\n    const columnIndex = columns1.findIndex(col => col.key === key);\n    if (columnIndex === -1) return;\n    return $30561577df230a30$export$59185c62a7544aa0(columns1[columnIndex].props.maxWidth, tableWidth.current);\n  }, [columns1]);\n  return {\n    columnWidths: columnWidthsRef,\n    setTableWidth: setTableWidth,\n    onColumnResize: onColumnResize,\n    onColumnResizeStart: onColumnResizeStart,\n    onColumnResizeEnd: onColumnResizeEnd,\n    getColumnWidth: getColumnWidth,\n    getColumnMinWidth: getColumnMinWidth,\n    getColumnMaxWidth: getColumnMaxWidth,\n    currentlyResizingColumn: currentlyResizingColumn\n  };\n}\n\nconst $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);\n\nfunction $788781baa30117fa$var$buildHeaderRows(keyMap, columnNodes) {\n  let columns = [];\n  let seen = new Map();\n\n  for (let column of columnNodes) {\n    let parentKey = column.parentKey;\n    let col = [column];\n\n    while (parentKey) {\n      let parent = keyMap.get(parentKey); // If we've already seen this parent, than it is shared\n      // with a previous column. If the current column is taller\n      // than the previous column, than we need to shift the parent\n      // in the previous column so it's level with the current column.\n\n      if (seen.has(parent)) {\n        parent.colspan++;\n        let {\n          column: column,\n          index: index\n        } = seen.get(parent);\n        if (index > col.length) break;\n\n        for (let i = index; i < col.length; i++) column.splice(i, 0, null); // Adjust shifted indices\n\n\n        for (let i1 = col.length; i1 < column.length; i1++) if (column[i1] && seen.has(column[i1])) seen.get(column[i1]).index = i1;\n      } else {\n        parent.colspan = 1;\n        col.push(parent);\n        seen.set(parent, {\n          column: col,\n          index: col.length - 1\n        });\n      }\n\n      parentKey = parent.parentKey;\n    }\n\n    columns.push(col);\n    column.index = columns.length - 1;\n  }\n\n  let maxLength = Math.max(...columns.map(c => c.length));\n  let headerRows = Array(maxLength).fill(0).map(() => []); // Convert columns into rows.\n\n  let colIndex = 0;\n\n  for (let column1 of columns) {\n    let i = maxLength - 1;\n\n    for (let item of column1) {\n      if (item) {\n        // Fill the space up until the current column with a placeholder\n        let row = headerRows[i];\n        let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n\n        if (rowLength < colIndex) {\n          let placeholder = {\n            type: 'placeholder',\n            key: 'placeholder-' + item.key,\n            colspan: colIndex - rowLength,\n            index: rowLength,\n            value: null,\n            rendered: null,\n            level: i,\n            hasChildNodes: false,\n            childNodes: [],\n            textValue: null\n          };\n\n          if (row.length > 0) {\n            row[row.length - 1].nextKey = placeholder.key;\n            placeholder.prevKey = row[row.length - 1].key;\n          }\n\n          row.push(placeholder);\n        }\n\n        if (row.length > 0) {\n          row[row.length - 1].nextKey = item.key;\n          item.prevKey = row[row.length - 1].key;\n        }\n\n        item.level = i;\n        item.colIndex = colIndex;\n        row.push(item);\n      }\n\n      i--;\n    }\n\n    colIndex++;\n  } // Add placeholders at the end of each row that is shorter than the maximum\n\n\n  let i = 0;\n\n  for (let row1 of headerRows) {\n    let rowLength = row1.reduce((p, c) => p + c.colspan, 0);\n\n    if (rowLength < columnNodes.length) {\n      let placeholder = {\n        type: 'placeholder',\n        key: 'placeholder-' + row1[row1.length - 1].key,\n        colspan: columnNodes.length - rowLength,\n        index: rowLength,\n        value: null,\n        rendered: null,\n        level: i,\n        hasChildNodes: false,\n        childNodes: [],\n        textValue: null,\n        prevKey: row1[row1.length - 1].key\n      };\n      row1.push(placeholder);\n    }\n\n    i++;\n  }\n\n  return headerRows.map((childNodes, index) => {\n    let row = {\n      type: 'headerrow',\n      key: 'headerrow-' + index,\n      index: index,\n      value: null,\n      rendered: null,\n      level: 0,\n      hasChildNodes: true,\n      childNodes: childNodes,\n      textValue: null\n    };\n    return row;\n  });\n}\n\nvar tmp = Symbol.iterator;\n\nclass $788781baa30117fa$export$596e1b2e2cf93690 extends $1BfjW$GridCollection {\n  *[tmp]() {\n    yield* this.body.childNodes;\n  }\n\n  get size() {\n    return [...this.body.childNodes].length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    var ref;\n    return (ref = [...this.body.childNodes][0]) === null || ref === void 0 ? void 0 : ref.key;\n  }\n\n  getLastKey() {\n    var ref;\n    let rows = [...this.body.childNodes];\n    return (ref = rows[rows.length - 1]) === null || ref === void 0 ? void 0 : ref.key;\n  }\n\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n  constructor(nodes, prev, opts) {\n    let rowHeaderColumnKeys = new Set();\n    let body;\n    let columns = []; // Add cell for selection checkboxes if needed.\n\n    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n      let rowHeaderColumn = {\n        type: 'column',\n        key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isSelectionCell: true\n        }\n      };\n      columns.unshift(rowHeaderColumn);\n    }\n\n    let rows = [];\n    let columnKeyMap = new Map();\n\n    let visit = node => {\n      switch (node.type) {\n        case 'body':\n          body = node;\n          break;\n\n        case 'column':\n          columnKeyMap.set(node.key, node);\n\n          if (!node.hasChildNodes) {\n            columns.push(node);\n            if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);\n          }\n\n          break;\n\n        case 'item':\n          rows.push(node);\n          return;\n        // do not go into childNodes\n      }\n\n      for (let child of node.childNodes) visit(child);\n    };\n\n    for (let node1 of nodes) visit(node1);\n\n    let headerRows = $788781baa30117fa$var$buildHeaderRows(columnKeyMap, columns);\n    headerRows.forEach((row, i) => rows.splice(i, 0, row));\n    super({\n      columnCount: columns.length,\n      items: rows,\n      visitNode: node => {\n        node.column = columns[node.index];\n        return node;\n      }\n    });\n    this.columns = columns;\n    this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n    this.body = body;\n    this.headerRows = headerRows; // Default row header column to the first one.\n\n    if (this.rowHeaderColumnKeys.size === 0) this.rowHeaderColumnKeys.add(this.columns[(opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) ? 1 : 0].key);\n  }\n\n}\n\nconst $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {\n  ascending: 'descending',\n  descending: 'ascending'\n};\n\nfunction $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {\n  let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = $1BfjW$useState(false);\n  let {\n    selectionMode = 'none'\n  } = props;\n  let context = $1BfjW$useMemo(() => ({\n    showSelectionCheckboxes: props.showSelectionCheckboxes && selectionMode !== 'none',\n    selectionMode: selectionMode,\n    columns: []\n  }), [props.children, props.showSelectionCheckboxes, selectionMode]);\n  let collection = $1BfjW$useCollection(props, (nodes, prev) => new $788781baa30117fa$export$596e1b2e2cf93690(nodes, prev, context), context);\n  let {\n    disabledKeys: disabledKeys,\n    selectionManager: selectionManager\n  } = $1BfjW$useGridState({ ...props,\n    collection: collection\n  });\n  return {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    selectionManager: selectionManager,\n    showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n    sortDescriptor: props.sortDescriptor,\n    isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,\n    setKeyboardNavigationDisabled: setKeyboardNavigationDisabled,\n\n    sort(columnKey, direction) {\n      var ref;\n      props.onSortChange({\n        column: columnKey,\n        direction: direction !== null && direction !== void 0 ? direction : ((ref = props.sortDescriptor) === null || ref === void 0 ? void 0 : ref.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : 'ascending'\n      });\n    }\n\n  };\n}\n\nfunction $312ae3b56a94a86e$var$TableHeader(props) {\n  return null;\n}\n\n$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props) {\n  let {\n    children: children,\n    columns: columns\n  } = props;\n\n  if (typeof children === 'function') {\n    if (!columns) throw new Error('props.children was a function but props.columns is missing');\n\n    for (let column of columns) yield {\n      type: 'column',\n      value: column,\n      renderer: children\n    };\n  } else {\n    let columns = [];\n    $1BfjW$react.Children.forEach(children, column => {\n      columns.push({\n        type: 'column',\n        element: column\n      });\n    });\n    yield* columns;\n  }\n};\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\n\n\nlet $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;\n\nfunction $4ae5314bf50db1a3$var$TableBody(props) {\n  return null;\n}\n\n$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode(props) {\n  let {\n    children: children,\n    items: items1\n  } = props;\n  yield {\n    type: 'body',\n    hasChildNodes: true,\n    props: props,\n\n    *childNodes() {\n      if (typeof children === 'function') {\n        if (!items1) throw new Error('props.children was a function but props.items is missing');\n\n        for (let item of items1) yield {\n          type: 'item',\n          value: item,\n          renderer: children\n        };\n      } else {\n        let items = [];\n        $1BfjW$react.Children.forEach(children, item => {\n          items.push({\n            type: 'item',\n            element: item\n          });\n        });\n        yield* items;\n      }\n    }\n\n  };\n};\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\n\n\nlet $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;\n\nfunction $1cd244557c2f97d5$var$Column(props) {\n  return null;\n}\n\n$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode(props, context1) {\n  let {\n    title: title,\n    children: children,\n    childColumns: childColumns1\n  } = props;\n  let rendered = title || children;\n  let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'];\n  let fullNodes = yield {\n    type: 'column',\n    hasChildNodes: !!childColumns1 || title && $1BfjW$react.Children.count(children) > 0,\n    rendered: rendered,\n    textValue: textValue,\n    props: props,\n\n    *childNodes() {\n      if (childColumns1) for (let child1 of childColumns1) yield {\n        type: 'column',\n        value: child1\n      };else if (title) {\n        let childColumns = [];\n        $1BfjW$react.Children.forEach(children, child => {\n          childColumns.push({\n            type: 'column',\n            element: child\n          });\n        });\n        yield* childColumns;\n      }\n    },\n\n    shouldInvalidate(newContext) {\n      // This is a bit of a hack, but it works.\n      // If this method is called, then there's a cached version of this node available.\n      // But, we need to keep the list of columns in the new context up to date.\n      updateContext(newContext);\n      return false;\n    }\n\n  };\n\n  let updateContext = context => {\n    // register leaf columns on the context so that <Row> can access them\n    for (let node of fullNodes) if (!node.hasChildNodes) context.columns.push(node);\n  };\n\n  updateContext(context1);\n};\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\n\n\nlet $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;\n\nfunction $70d70eb16ea48428$var$Row(props) {\n  return null;\n}\n\n$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode(props, context) {\n  let {\n    children: children,\n    textValue: textValue\n  } = props;\n  yield {\n    type: 'item',\n    props: props,\n    textValue: textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: true,\n\n    *childNodes() {\n      // Process cells first\n      if (context.showSelectionCheckboxes && context.selectionMode !== 'none') yield {\n        type: 'cell',\n        key: 'header',\n        props: {\n          isSelectionCell: true\n        }\n      };\n      if (typeof children === 'function') for (let column of context.columns) yield {\n        type: 'cell',\n        element: children(column.key),\n        key: column.key // this is combined with the row key by CollectionBuilder\n\n      };else {\n        let cells = [];\n        $1BfjW$react.Children.forEach(children, cell => {\n          cells.push({\n            type: 'cell',\n            element: cell\n          });\n        });\n        if (cells.length !== context.columns.length) throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n        yield* cells;\n      }\n    },\n\n    shouldInvalidate(newContext) {\n      // Invalidate all rows if the columns changed.\n      return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i) => c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.selectionMode !== context.selectionMode;\n    }\n\n  };\n};\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */\n// We don't want getCollectionNode to show up in the type definition\n\n\nlet $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;\n\nfunction $941d1d9a6a28982a$var$Cell(props) {\n  return null;\n}\n\n$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode(props) {\n  let {\n    children: children\n  } = props;\n  let textValue = props.textValue || (typeof children === 'string' ? children : '') || props['aria-label'] || '';\n  yield {\n    type: 'cell',\n    props: props,\n    rendered: children,\n    textValue: textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: false\n  };\n};\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */\n// We don't want getCollectionNode to show up in the type definition\n\n\nlet $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;\nexport { $292bc4e09cd0eb62$export$cb895dcf85db1319 as useTableColumnResizeState, $4a0dd036d492cee4$export$907bcc6c48325fd6 as useTableState, $312ae3b56a94a86e$export$f850895b287ef28e as TableHeader, $4ae5314bf50db1a3$export$76ccd210b9029917 as TableBody, $1cd244557c2f97d5$export$816b5d811295e6bc as Column, $70d70eb16ea48428$export$b59bdbef9ce70de2 as Row, $941d1d9a6a28982a$export$f6f0c3fe4ec306ea as Cell, $6555104ff085bef4$re_export$Section as Section };","map":{"version":3,"mappings":"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","names":["$30561577df230a30$export$f61abf052f87399f","widths","Array","from","map","e","reduce","acc","cur","$30561577df230a30$export$1994a077b98ee0d5","width","isNaN","String","match","$30561577df230a30$var$parseFractionalUnit","console","warn","parseInt","$30561577df230a30$export$7bbad27896f7ae9f","tableWidth","Error","$30561577df230a30$export$59185c62a7544aa0","maxWidth","Number","MAX_SAFE_INTEGER","$30561577df230a30$export$f556054ce4358701","minWidth","$30561577df230a30$var$mapDynamicColumns","dynamicColumns","availableSpace","fractions","sum","column","props","defaultWidth","columns","index","targetWidth","delta","Math","max","$30561577df230a30$var$findDynamicColumnWidths","col","min","floor","calculatedWidth","$30561577df230a30$export$a870e6692ac5ccb2","sort","a","b","$292bc4e09cd0eb62$export$cb895dcf85db1319","state","getDefaultWidth","defaultTableWidth","columnsRef","$1BfjW$useRef","isResizing","startResizeContentWidth","columnWidths","setColumnWidths","$1BfjW$useState","Map","columns1","key","columnWidthsRef","affectedColumnWidthsRef","resizedColumns","setResizedColumns","Set","resizedColumnsRef","currentlyResizingColumn","setCurrentlyResizingColumn","setColumnWidthsForRef","newWidths","current","getResolvedColumnWidth","$1BfjW$useCallback","columnProps","_width","has","get","ref1","ref","getStaticAndDynamicColumns","staticColumns","buildColumnWidths","affectedColumns","remainingSpace","forEach","w","set","length","newColumnWidths","prevColKeys","colKeys","every","i","setTableWidth","onColumnResizeStart","onColumnResize","widthsObj","resizeColumn","onColumnResizeEnd","column1","newWidth","boundedWidth","add","resizeIndex","findIndex","slice","recalculatedColumnWidths","allAffectedColumns","ref2","getColumnWidth","getColumnMinWidth","columnIndex","getColumnMaxWidth","$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY","random","toString","$788781baa30117fa$var$buildHeaderRows","keyMap","columnNodes","seen","parentKey","parent","colspan","splice","i1","push","maxLength","c","headerRows","fill","colIndex","item","row","rowLength","p","placeholder","type","value","rendered","level","hasChildNodes","childNodes","textValue","nextKey","prevKey","row1","Symbol","iterator","$788781baa30117fa$export$596e1b2e2cf93690","$1BfjW$GridCollection","body","size","getKeys","keys","getKeyBefore","node","getKeyAfter","getFirstKey","getLastKey","rows","getItem","at","idx","nodes","prev","opts","rowHeaderColumnKeys","showSelectionCheckboxes","rowHeaderColumn","isSelectionCell","unshift","columnKeyMap","visit","isRowHeader","child","node1","columnCount","items","visitNode","$4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION","ascending","descending","$4a0dd036d492cee4$export$907bcc6c48325fd6","isKeyboardNavigationDisabled","setKeyboardNavigationDisabled","selectionMode","context","$1BfjW$useMemo","children","collection","$1BfjW$useCollection","disabledKeys","selectionManager","$1BfjW$useGridState","sortDescriptor","columnKey","direction","onSortChange","$312ae3b56a94a86e$var$TableHeader","getCollectionNode","renderer","$1BfjW$react","Children","element","$312ae3b56a94a86e$export$f850895b287ef28e","$4ae5314bf50db1a3$var$TableBody","items1","$4ae5314bf50db1a3$export$76ccd210b9029917","$1cd244557c2f97d5$var$Column","context1","title","childColumns","childColumns1","fullNodes","count","child1","shouldInvalidate","newContext","updateContext","$1cd244557c2f97d5$export$816b5d811295e6bc","$70d70eb16ea48428$var$Row","cells","cell","some","$70d70eb16ea48428$export$b59bdbef9ce70de2","$941d1d9a6a28982a$var$Cell","$941d1d9a6a28982a$export$f6f0c3fe4ec306ea"],"sources":["/Users/vux/dev/react-project1/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/utils.ts","/Users/vux/dev/react-project1/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/useTableColumnResizeState.ts","/Users/vux/dev/react-project1/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/TableCollection.ts","/Users/vux/dev/react-project1/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/useTableState.ts","/Users/vux/dev/react-project1/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/TableHeader.ts","/Users/vux/dev/react-project1/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/TableBody.ts","/Users/vux/dev/react-project1/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/Column.ts","/Users/vux/dev/react-project1/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/Row.ts","/Users/vux/dev/react-project1/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/Cell.ts"],"sourcesContent":["import {GridNode} from '@react-types/grid';\nimport {Key} from 'react';\n\ntype mappedColumn<T> = GridNode<T> & {\n    index: number,\n    delta: number,\n    calculatedWidth?: number\n};\n\nexport function getContentWidth(widths: Map<Key, number>): number {\n  return Array.from(widths).map(e => e[1]).reduce((acc, cur) => acc + cur, 0);\n}\n\n// numbers and percents are considered static. *fr units or a lack of units are considered dynamic.\nexport function isStatic(width: number | string): boolean {\n  return width != null && (!isNaN(width as number) || (String(width)).match(/^(\\d+)(?=%$)/) !== null);\n}\n\nfunction parseFractionalUnit(width: string): number {\n  if (!width) {\n    return 1;\n  }\n  let match = width.match(/^(\\d+)(?=fr$)/);\n      // if width is the incorrect format, just deafult it to a 1fr\n  if (!match) {\n    console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`,\n        'defaulting to \\'1fr\\'');\n    return 1;\n  }\n  return parseInt(match[0], 10);\n}\n\nexport function parseStaticWidth(width: number | string, tableWidth: number): number {\n  if (typeof width === 'string') {\n    let match = width.match(/^(\\d+)(?=%$)/);\n    if (!match) {\n      throw new Error('Only percentages or numbers are supported for static column widths');\n    }\n    return tableWidth * (parseInt(match[0], 10) / 100);\n  }\n  return width;\n}\n\n\nexport function getMaxWidth(maxWidth: number | string, tableWidth: number): number {\n  return maxWidth != null\n        ? parseStaticWidth(maxWidth, tableWidth)\n        : Number.MAX_SAFE_INTEGER;\n}\n\nexport function getMinWidth(minWidth: number | string, tableWidth: number): number {\n  return minWidth != null\n      ? parseStaticWidth(minWidth, tableWidth)\n      : 75;\n}\n\nfunction mapDynamicColumns<T>(dynamicColumns: GridNode<T>[], availableSpace: number, tableWidth: number): mappedColumn<T>[] {\n  let fractions = dynamicColumns.reduce(\n        (sum, column) => sum + parseFractionalUnit(column.props.defaultWidth),\n        0\n      );\n\n  let columns = dynamicColumns.map((column, index) => {\n    const targetWidth =\n          (parseFractionalUnit(column.props.defaultWidth) * availableSpace) / fractions;\n    const delta = Math.max(\n      getMinWidth(column.props.minWidth, tableWidth) - targetWidth,\n      targetWidth - getMaxWidth(column.props.maxWidth, tableWidth)\n    );\n\n    return {\n      ...column,\n      index,\n      delta\n    };\n  });\n\n  return columns;\n}\n\nfunction findDynamicColumnWidths<T>(dynamicColumns: mappedColumn<T>[], availableSpace: number, tableWidth: number): mappedColumn<T>[] {\n  let fractions = dynamicColumns.reduce(\n    (sum, col) => sum + parseFractionalUnit(col.props.defaultWidth),\n    0\n  );\n\n  const columns = dynamicColumns.map((column) => {\n    const targetWidth =\n      (parseFractionalUnit(column.props.defaultWidth) * availableSpace) / fractions;\n    let width = Math.max(\n      getMinWidth(column.props.minWidth, tableWidth),\n      Math.min(Math.floor(targetWidth), getMaxWidth(column.props.maxWidth, tableWidth))\n    );\n    column.calculatedWidth = width;\n    availableSpace -= width;\n    fractions -= parseFractionalUnit(column.props.defaultWidth);\n    return column;\n  });\n\n  return columns;\n}\n\nexport function getDynamicColumnWidths<T>(dynamicColumns: GridNode<T>[], availableSpace: number, tableWidth: number) {\n  let columns = mapDynamicColumns(dynamicColumns, availableSpace, tableWidth);\n\n  columns.sort((a, b) => b.delta - a.delta);\n  columns = findDynamicColumnWidths(columns, availableSpace, tableWidth);\n  columns.sort((a, b) => a.index - b.index);\n\n  return columns;\n}\n","\nimport {ColumnProps} from '@react-types/table';\nimport {getContentWidth, getDynamicColumnWidths, getMaxWidth, getMinWidth, isStatic, parseStaticWidth} from './utils';\nimport {GridNode} from '@react-types/grid';\nimport {Key, MutableRefObject, useCallback, useRef, useState} from 'react';\n\ninterface AffectedColumnWidth {\n  /** The column key. */\n  key: Key,\n  /** The column width. */\n  width: number\n}\ninterface AffectedColumnWidths extends Array<AffectedColumnWidth> {}\n\nexport interface TableColumnResizeState<T> {\n  /** A ref whose current value is the state of all the column widths. */\n  columnWidths: MutableRefObject<Map<Key, number>>,\n  /** Setter for the table width. */\n  setTableWidth: (width: number) => void,\n  /** Trigger a resize and recalculation. */\n  onColumnResize: (column: GridNode<T>, width: number) => void,\n  /** Callback for when onColumnResize has started. */\n  onColumnResizeStart: (column: GridNode<T>) => void,\n  /** Callback for when onColumnResize has ended. */\n  onColumnResizeEnd: (column: GridNode<T>) => void,\n  /** Getter for column width. */\n  getColumnWidth: (key: Key) => number,\n  /** Getter for column min width. */\n  getColumnMinWidth: (key: Key) => number,\n  /** Getter for column max widths. */\n  getColumnMaxWidth: (key: Key) => number,\n  /** Key of column currently being resized. */\n  currentlyResizingColumn: Key | null\n}\n\nexport interface TableColumnResizeStateProps {\n  /** Callback to determine what the default width of a column should be. */\n  getDefaultWidth?: (props) => string | number,\n  /** Callback that is invoked during the entirety of the resize event. */\n  onColumnResize?: (affectedColumnWidths: AffectedColumnWidths) => void,\n  /** Callback that is invoked when the resize event is ended. */\n  onColumnResizeEnd?: (affectedColumnWidths: AffectedColumnWidths) => void,\n  /** The default table width. */\n  tableWidth?: number\n}\n\ninterface ColumnState<T> {\n  columns: GridNode<T>[]\n}\n\nexport function useTableColumnResizeState<T>(props: TableColumnResizeStateProps, state: ColumnState<T>): TableColumnResizeState<T> {\n  const {getDefaultWidth, tableWidth: defaultTableWidth = null} = props;\n  const {columns} = state;\n  const columnsRef = useRef<GridNode<T>[]>([]);\n  const tableWidth = useRef<number>(defaultTableWidth);\n  const isResizing = useRef<boolean>(null);\n  const startResizeContentWidth = useRef<number>();\n\n  const [columnWidths, setColumnWidths] = useState<Map<Key, number>>(new Map(columns.map(col => [col.key, 0])));\n  const columnWidthsRef = useRef<Map<Key, number>>(columnWidths);\n  const affectedColumnWidthsRef = useRef<AffectedColumnWidths>([]);\n  const [resizedColumns, setResizedColumns] = useState<Set<Key>>(new Set());\n  const resizedColumnsRef = useRef<Set<Key>>(resizedColumns);\n\n  const [currentlyResizingColumn, setCurrentlyResizingColumn] = useState<Key>(null);\n\n  function setColumnWidthsForRef(newWidths: Map<Key, number>) {\n    columnWidthsRef.current = newWidths;\n    // new map so that change detection is triggered\n    setColumnWidths(newWidths);\n  }\n  /*\n    returns the resolved column width in this order:\n    previously calculated width -> controlled width prop -> uncontrolled defaultWidth prop -> dev assigned width -> default dynamic width\n  */\n  let getResolvedColumnWidth = useCallback((column: GridNode<T>): (number | string) => {\n    let columnProps = column.props as ColumnProps<T>;\n    return resizedColumns?.has(column.key) ? columnWidthsRef.current.get(column.key) : columnProps.width ?? columnProps.defaultWidth ?? getDefaultWidth?.(column.props) ?? '1fr';\n  }, [getDefaultWidth, resizedColumns]);\n\n  let getStaticAndDynamicColumns = useCallback((columns: GridNode<T>[]) : { staticColumns: GridNode<T>[], dynamicColumns: GridNode<T>[] } => columns.reduce((acc, column) => {\n    let width = getResolvedColumnWidth(column);\n    return isStatic(width) ? {...acc, staticColumns: [...acc.staticColumns, column]} : {...acc, dynamicColumns: [...acc.dynamicColumns, column]};\n  }, {staticColumns: [], dynamicColumns: []}), [getResolvedColumnWidth]);\n\n  let buildColumnWidths = useCallback((affectedColumns: GridNode<T>[], availableSpace: number): Map<Key, number> => {\n    const widths = new Map<Key, number>();\n    let remainingSpace = availableSpace;\n\n    const {staticColumns, dynamicColumns} = getStaticAndDynamicColumns(affectedColumns);\n\n    staticColumns.forEach(column => {\n      let width = getResolvedColumnWidth(column);\n      let w = parseStaticWidth(width, tableWidth.current);\n      widths.set(column.key, w);\n      remainingSpace -= w;\n    });\n\n    // dynamic columns\n    if (dynamicColumns.length > 0) {\n      const newColumnWidths = getDynamicColumnWidths(dynamicColumns, remainingSpace, tableWidth.current);\n      for (let column of newColumnWidths) {\n        widths.set(column.key, column.calculatedWidth);\n      }\n    }\n\n    return widths;\n  }, [getStaticAndDynamicColumns, getResolvedColumnWidth]);\n\n\n  const prevColKeys = columnsRef.current.map(col => col.key);\n  const colKeys = columns.map(col => col.key);\n  // if the columns change, need to rebuild widths.\n  if (prevColKeys.length !== colKeys.length || !colKeys.every((col, i) => col === prevColKeys[i])) {\n    columnsRef.current = columns;\n    const widths = buildColumnWidths(columns, tableWidth.current);\n    setColumnWidthsForRef(widths);\n  }\n\n  function setTableWidth(width: number) {\n    if (width && width !== tableWidth.current) {\n      tableWidth.current = width;\n      if (!isResizing.current) {\n        const widths = buildColumnWidths(columns, width);\n        setColumnWidthsForRef(widths);\n      }\n    }\n  }\n\n  function onColumnResizeStart(column: GridNode<T>) {\n    setCurrentlyResizingColumn(column.key);\n    isResizing.current = true;\n    startResizeContentWidth.current = getContentWidth(columnWidthsRef.current);\n  }\n\n  function onColumnResize(column: GridNode<T>, width: number) {\n    let widthsObj = resizeColumn(column, width);\n    affectedColumnWidthsRef.current = widthsObj;\n    props.onColumnResize && props.onColumnResize(affectedColumnWidthsRef.current);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function onColumnResizeEnd(column: GridNode<T>) {\n    props.onColumnResizeEnd && isResizing.current && props.onColumnResizeEnd(affectedColumnWidthsRef.current);\n    setCurrentlyResizingColumn(null);\n    isResizing.current = false;\n    affectedColumnWidthsRef.current = [];\n\n    let widths = new Map<Key, number>(columnWidthsRef.current);\n    setColumnWidthsForRef(widths);\n  }\n\n  function resizeColumn(column: GridNode<T>, newWidth: number) : AffectedColumnWidths {\n    let boundedWidth =  Math.max(\n      getMinWidth(column.props.minWidth, tableWidth.current),\n      Math.min(Math.floor(newWidth), getMaxWidth(column.props.maxWidth, tableWidth.current)));\n\n    // copy the columnWidths map and set the new width for the column being resized\n    let widths = new Map<Key, number>(columnWidthsRef.current);\n    widths.set(column.key, boundedWidth);\n\n    // keep track of all columns that have been sized\n    resizedColumnsRef.current.add(column.key);\n    setResizedColumns(resizedColumnsRef.current);\n\n    // get the columns affected by resize and remaining space\n    const resizeIndex = columnsRef.current.findIndex(col => col.key === column.key);\n    let affectedColumns = columnsRef.current.slice(resizeIndex + 1);\n\n    // we only care about the columns that CAN be resized, we ignore static columns.\n    let {dynamicColumns} = getStaticAndDynamicColumns(affectedColumns);\n\n    // available space for affected columns\n    let availableSpace = columnsRef.current.reduce((acc, column, index) => {\n      if (index <= resizeIndex || isStatic(getResolvedColumnWidth(column))) {\n        return acc - widths.get(column.key);\n      }\n      return acc;\n    }, tableWidth.current);\n\n    // merge the unaffected column widths and the recalculated column widths\n    let recalculatedColumnWidths = buildColumnWidths(dynamicColumns, availableSpace);\n    widths = new Map<Key, number>([...widths, ...recalculatedColumnWidths]);\n\n    setColumnWidthsForRef(widths);\n\n    /*\n     when getting recalculated columns above, the column being resized is not considered \"recalculated\"\n     so we need to add it to the list of affected columns\n    */\n    let allAffectedColumns = ([[column.key, boundedWidth], ...recalculatedColumnWidths] as [Key, number][]).map(([key, width]) => ({key, width}));\n    return allAffectedColumns;\n  }\n\n  // This function is regenerated whenever columnWidthsRef.current changes in order to get the new correct ref value.\n  let getColumnWidth = useCallback((key: Key): number => columnWidthsRef.current.get(key) ?? 0, [columnWidthsRef.current]);\n\n  let getColumnMinWidth = useCallback((key: Key) => {\n    const columnIndex = columns.findIndex(col => col.key === key);\n    if (columnIndex === -1) {\n      return;\n    }\n    return getMinWidth(columns[columnIndex].props.minWidth, tableWidth.current);\n  }, [columns]);\n\n  let getColumnMaxWidth = useCallback((key: Key) => {\n    const columnIndex = columns.findIndex(col => col.key === key);\n    if (columnIndex === -1) {\n      return;\n    }\n    return getMaxWidth(columns[columnIndex].props.maxWidth, tableWidth.current);\n  }, [columns]);\n\n  return {\n    columnWidths: columnWidthsRef,\n    setTableWidth,\n    onColumnResize,\n    onColumnResizeStart,\n    onColumnResizeEnd,\n    getColumnWidth,\n    getColumnMinWidth,\n    getColumnMaxWidth,\n    currentlyResizingColumn\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {GridCollection} from '@react-stately/grid';\nimport {GridNode} from '@react-types/grid';\nimport {Key} from 'react';\n\ninterface GridCollectionOptions {\n  showSelectionCheckboxes?: boolean\n}\n\nconst ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);\n\nfunction buildHeaderRows<T>(keyMap: Map<Key, GridNode<T>>, columnNodes: GridNode<T>[]): GridNode<T>[] {\n  let columns: GridNode<T>[][] = [];\n  let seen = new Map();\n  for (let column of columnNodes) {\n    let parentKey = column.parentKey;\n    let col = [column];\n\n    while (parentKey) {\n      let parent: GridNode<T> = keyMap.get(parentKey);\n\n      // If we've already seen this parent, than it is shared\n      // with a previous column. If the current column is taller\n      // than the previous column, than we need to shift the parent\n      // in the previous column so it's level with the current column.\n      if (seen.has(parent)) {\n        parent.colspan++;\n\n        let {column, index} = seen.get(parent);\n        if (index > col.length) {\n          break;\n        }\n\n        for (let i = index; i < col.length; i++) {\n          column.splice(i, 0, null);\n        }\n\n        // Adjust shifted indices\n        for (let i = col.length; i < column.length; i++) {\n          if (column[i] && seen.has(column[i])) {\n            seen.get(column[i]).index = i;\n          }\n        }\n      } else {\n        parent.colspan = 1;\n        col.push(parent);\n        seen.set(parent, {column: col, index: col.length - 1});\n      }\n\n      parentKey = parent.parentKey;\n    }\n\n    columns.push(col);\n    column.index = columns.length - 1;\n  }\n\n  let maxLength = Math.max(...columns.map(c => c.length));\n  let headerRows = Array(maxLength).fill(0).map(() => []);\n\n  // Convert columns into rows.\n  let colIndex = 0;\n  for (let column of columns) {\n    let i = maxLength - 1;\n    for (let item of column) {\n      if (item) {\n        // Fill the space up until the current column with a placeholder\n        let row = headerRows[i];\n        let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n        if (rowLength < colIndex) {\n          let placeholder: GridNode<T> = {\n            type: 'placeholder',\n            key: 'placeholder-' + item.key,\n            colspan: colIndex - rowLength,\n            index: rowLength,\n            value: null,\n            rendered: null,\n            level: i,\n            hasChildNodes: false,\n            childNodes: [],\n            textValue: null\n          };\n\n          if (row.length > 0) {\n            row[row.length - 1].nextKey = placeholder.key;\n            placeholder.prevKey = row[row.length - 1].key;\n          }\n\n          row.push(placeholder);\n        }\n\n        if (row.length > 0) {\n          row[row.length - 1].nextKey = item.key;\n          item.prevKey = row[row.length - 1].key;\n        }\n\n        item.level = i;\n        item.colIndex = colIndex;\n        row.push(item);\n      }\n\n      i--;\n    }\n\n    colIndex++;\n  }\n\n  // Add placeholders at the end of each row that is shorter than the maximum\n  let i = 0;\n  for (let row of headerRows) {\n    let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n    if (rowLength < columnNodes.length) {\n      let placeholder: GridNode<T> = {\n        type: 'placeholder',\n        key: 'placeholder-' + row[row.length - 1].key,\n        colspan: columnNodes.length - rowLength,\n        index: rowLength,\n        value: null,\n        rendered: null,\n        level: i,\n        hasChildNodes: false,\n        childNodes: [],\n        textValue: null,\n        prevKey: row[row.length - 1].key\n      };\n\n      row.push(placeholder);\n    }\n\n    i++;\n  }\n\n  return headerRows.map((childNodes, index) => {\n    let row: GridNode<T> = {\n      type: 'headerrow',\n      key: 'headerrow-' + index,\n      index,\n      value: null,\n      rendered: null,\n      level: 0,\n      hasChildNodes: true,\n      childNodes,\n      textValue: null\n    };\n\n    return row;\n  });\n}\n\nexport class TableCollection<T> extends GridCollection<T> {\n  headerRows: GridNode<T>[];\n  columns: GridNode<T>[];\n  rowHeaderColumnKeys: Set<Key>;\n  body: GridNode<T>;\n\n  constructor(nodes: Iterable<GridNode<T>>, prev?: TableCollection<T>, opts?: GridCollectionOptions) {\n    let rowHeaderColumnKeys: Set<Key> = new Set();\n    let body: GridNode<T>;\n    let columns = [];\n\n    // Add cell for selection checkboxes if needed.\n    if (opts?.showSelectionCheckboxes) {\n      let rowHeaderColumn: GridNode<T> = {\n        type: 'column',\n        key: ROW_HEADER_COLUMN_KEY,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isSelectionCell: true\n        }\n      };\n\n      columns.unshift(rowHeaderColumn);\n    }\n\n    let rows = [];\n    let columnKeyMap = new Map();\n    let visit = (node: GridNode<T>) => {\n      switch (node.type) {\n        case 'body':\n          body = node;\n          break;\n        case 'column':\n          columnKeyMap.set(node.key, node);\n          if (!node.hasChildNodes) {\n            columns.push(node);\n\n            if (node.props.isRowHeader) {\n              rowHeaderColumnKeys.add(node.key);\n            }\n          }\n          break;\n        case 'item':\n          rows.push(node);\n          return; // do not go into childNodes\n      }\n      for (let child of node.childNodes) {\n        visit(child);\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let headerRows = buildHeaderRows(columnKeyMap, columns) as GridNode<T>[];\n    headerRows.forEach((row, i) => rows.splice(i, 0, row));\n\n    super({\n      columnCount: columns.length,\n      items: rows,\n      visitNode: node => {\n        node.column = columns[node.index];\n        return node;\n      }\n    });\n    this.columns = columns;\n    this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n    this.body = body;\n    this.headerRows = headerRows;\n\n    // Default row header column to the first one.\n    if (this.rowHeaderColumnKeys.size === 0) {\n      this.rowHeaderColumnKeys.add(this.columns[opts?.showSelectionCheckboxes ? 1 : 0].key);\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.body.childNodes;\n  }\n\n  get size() {\n    return [...this.body.childNodes].length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return [...this.body.childNodes][0]?.key;\n  }\n\n  getLastKey() {\n    let rows = [...this.body.childNodes];\n    return rows[rows.length - 1]?.key;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBase, Node, SelectionMode, Sortable, SortDescriptor, SortDirection} from '@react-types/shared';\nimport {GridState, useGridState} from '@react-stately/grid';\nimport {TableCollection as ITableCollection} from '@react-types/table';\nimport {Key, useMemo, useState} from 'react';\nimport {MultipleSelectionStateProps} from '@react-stately/selection';\nimport {TableCollection} from './TableCollection';\nimport {useCollection} from '@react-stately/collections';\n\nexport interface TableState<T> extends GridState<T, ITableCollection<T>> {\n  /** A collection of rows and columns in the table. */\n  collection: ITableCollection<T>,\n  /** Whether the row selection checkboxes should be displayed. */\n  showSelectionCheckboxes: boolean,\n  /** The current sorted column and direction. */\n  sortDescriptor: SortDescriptor,\n  /** Calls the provided onSortChange handler with the provided column key and sort direction. */\n  sort(columnKey: Key, direction?: 'ascending' | 'descending'): void,\n  /** Whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  isKeyboardNavigationDisabled: boolean,\n  /** Set whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  setKeyboardNavigationDisabled: (val: boolean) => void\n}\n\nexport interface CollectionBuilderContext<T> {\n  showSelectionCheckboxes: boolean,\n  selectionMode: SelectionMode,\n  columns: Node<T>[]\n}\n\nexport interface TableStateProps<T> extends CollectionBase<T>, MultipleSelectionStateProps, Sortable {\n  /** Whether the row selection checkboxes should be displayed. */\n  showSelectionCheckboxes?: boolean\n}\n\nconst OPPOSITE_SORT_DIRECTION = {\n  ascending: 'descending' as SortDirection,\n  descending: 'ascending' as SortDirection\n};\n\n/**\n * Provides state management for a table component. Handles building a collection\n * of columns and rows from props. In addition, it tracks row selection and manages sort order changes.\n */\nexport function useTableState<T extends object>(props: TableStateProps<T>): TableState<T> {\n  let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = useState(false);\n  let {selectionMode = 'none'} = props;\n\n  let context = useMemo(() => ({\n    showSelectionCheckboxes: props.showSelectionCheckboxes && selectionMode !== 'none',\n    selectionMode,\n    columns: []\n  }), [props.children, props.showSelectionCheckboxes, selectionMode]);\n\n  let collection = useCollection<T, TableCollection<T>>(\n    props,\n    (nodes, prev) => new TableCollection(nodes, prev, context),\n    context\n  );\n  let {disabledKeys, selectionManager} = useGridState({...props, collection});\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager,\n    showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n    sortDescriptor: props.sortDescriptor,\n    isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,\n    setKeyboardNavigationDisabled,\n    sort(columnKey: Key, direction?: 'ascending' | 'descending') {\n      props.onSortChange({\n        column: columnKey,\n        direction: direction ?? (props.sortDescriptor?.column === columnKey\n          ? OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction]\n          : 'ascending')\n      });\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\nimport {TableHeaderProps} from '@react-types/table';\n\nfunction TableHeader<T>(props: TableHeaderProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nTableHeader.getCollectionNode = function* getCollectionNode<T>(props: TableHeaderProps<T>): Generator<PartialNode<T>, void, any> {\n  let {children, columns} = props;\n  if (typeof children === 'function') {\n    if (!columns) {\n      throw new Error('props.children was a function but props.columns is missing');\n    }\n\n    for (let column of columns) {\n      yield {\n        type: 'column',\n        value: column,\n        renderer: children\n      };\n    }\n  } else {\n    let columns: PartialNode<T>[] = [];\n    React.Children.forEach(children, column => {\n      columns.push({\n        type: 'column',\n        element: column\n      });\n    });\n\n    yield* columns;\n  }\n};\n\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _TableHeader = TableHeader as <T>(props: TableHeaderProps<T>) => JSX.Element;\nexport {_TableHeader as TableHeader};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\nimport {TableBodyProps} from '@react-types/table';\n\nfunction TableBody<T>(props: TableBodyProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nTableBody.getCollectionNode = function* getCollectionNode<T>(props: TableBodyProps<T>): Generator<PartialNode<T>> {\n  let {children, items} = props;\n  yield {\n    type: 'body',\n    hasChildNodes: true,\n    props,\n    *childNodes() {\n      if (typeof children === 'function') {\n        if (!items) {\n          throw new Error('props.children was a function but props.items is missing');\n        }\n\n        for (let item of items) {\n          yield {\n            type: 'item',\n            value: item,\n            renderer: children\n          };\n        }\n      } else {\n        let items: PartialNode<T>[] = [];\n        React.Children.forEach(children, item => {\n          items.push({\n            type: 'item',\n            element: item\n          });\n        });\n\n        yield* items;\n      }\n    }\n  };\n};\n\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _TableBody = TableBody as <T>(props: TableBodyProps<T>) => JSX.Element;\nexport {_TableBody as TableBody};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilderContext} from './useTableState';\nimport {ColumnProps} from '@react-types/table';\nimport {GridNode} from '@react-types/grid';\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\n\nfunction Column<T>(props: ColumnProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nColumn.getCollectionNode = function* getCollectionNode<T>(props: ColumnProps<T>, context: CollectionBuilderContext<T>): Generator<PartialNode<T>, void, GridNode<T>[]> {\n  let {title, children, childColumns} = props;\n\n  let rendered = title || children;\n  let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'];\n\n  let fullNodes = yield {\n    type: 'column',\n    hasChildNodes: !!childColumns || (title && React.Children.count(children) > 0),\n    rendered,\n    textValue,\n    props,\n    *childNodes() {\n      if (childColumns) {\n        for (let child of childColumns) {\n          yield {\n            type: 'column',\n            value: child\n          };\n        }\n      } else if (title) {\n        let childColumns: PartialNode<T>[] = [];\n        React.Children.forEach(children, child => {\n          childColumns.push({\n            type: 'column',\n            element: child as ReactElement<ColumnProps<T>>\n          });\n        });\n\n        yield* childColumns;\n      }\n    },\n    shouldInvalidate(newContext: CollectionBuilderContext<T>) {\n      // This is a bit of a hack, but it works.\n      // If this method is called, then there's a cached version of this node available.\n      // But, we need to keep the list of columns in the new context up to date.\n      updateContext(newContext);\n      return false;\n    }\n  };\n\n  let updateContext = (context: CollectionBuilderContext<T>) => {\n    // register leaf columns on the context so that <Row> can access them\n    for (let node of fullNodes) {\n      if (!node.hasChildNodes) {\n        context.columns.push(node);\n      }\n    }\n  };\n\n  updateContext(context);\n};\n\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _Column = Column as <T>(props: ColumnProps<T>) => JSX.Element;\nexport {_Column as Column};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilderContext} from './useTableState';\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\nimport {RowProps} from '@react-types/table';\n\nfunction Row(props: RowProps): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nRow.getCollectionNode = function* getCollectionNode<T>(props: RowProps, context: CollectionBuilderContext<T>): Generator<PartialNode<T>> {\n  let {children, textValue} = props;\n\n  yield {\n    type: 'item',\n    props: props,\n    textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: true,\n    *childNodes() {\n      // Process cells first\n      if (context.showSelectionCheckboxes && context.selectionMode !== 'none') {\n        yield {\n          type: 'cell',\n          key: 'header', // this is combined with the row key by CollectionBuilder\n          props: {\n            isSelectionCell: true\n          }\n        };\n      }\n\n      if (typeof children === 'function') {\n        for (let column of context.columns) {\n          yield {\n            type: 'cell',\n            element: children(column.key),\n            key: column.key // this is combined with the row key by CollectionBuilder\n          };\n        }\n      } else {\n        let cells: PartialNode<T>[] = [];\n        React.Children.forEach(children, cell => {\n          cells.push({\n            type: 'cell',\n            element: cell\n          });\n        });\n\n        if (cells.length !== context.columns.length) {\n          throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n        }\n\n        yield* cells;\n      }\n    },\n    shouldInvalidate(newContext: CollectionBuilderContext<T>) {\n      // Invalidate all rows if the columns changed.\n      return newContext.columns.length !== context.columns.length ||\n        newContext.columns.some((c, i) => c.key !== context.columns[i].key) ||\n        newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes ||\n        newContext.selectionMode !== context.selectionMode;\n    }\n  };\n};\n\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _Row = Row as (props: RowProps) => JSX.Element;\nexport {_Row as Row};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CellProps} from '@react-types/table';\nimport {PartialNode} from '@react-stately/collections';\nimport {ReactElement} from 'react';\n\nfunction Cell(props: CellProps): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nCell.getCollectionNode = function* getCollectionNode<T>(props: CellProps): Generator<PartialNode<T>> {\n  let {children} = props;\n\n  let textValue = props.textValue || (typeof children === 'string' ? children : '') || props['aria-label'] || '';\n  yield {\n    type: 'cell',\n    props: props,\n    rendered: children,\n    textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: false\n  };\n};\n\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _Cell = Cell as (props: CellProps) => JSX.Element;\nexport {_Cell as Cell};\n"]},"metadata":{},"sourceType":"module"}